\newcommand{\NWtarget}[2]{#2}
\newcommand{\NWlink}[2]{#2}
\newcommand{\NWtxtMacroDefBy}{Fragment defined by}
\newcommand{\NWtxtMacroRefIn}{Fragment referenced in}
\newcommand{\NWtxtMacroNoRef}{Fragment never referenced}
\newcommand{\NWtxtDefBy}{Defined by}
\newcommand{\NWtxtRefIn}{Referenced in}
\newcommand{\NWtxtNoRef}{Not referenced}
\newcommand{\NWtxtFileDefBy}{File defined by}
\newcommand{\NWtxtIdentsUsed}{Uses:}
\newcommand{\NWtxtIdentsNotUsed}{Never used}
\newcommand{\NWtxtIdentsDefed}{Defines:}
\newcommand{\NWsep}{${\diamond}$}
\newcommand{\NWnotglobal}{(not defined globally)}
\newcommand{\NWuseHyperlinks}{}
\documentclass[12pt]{article}
\usepackage{hyperref}
\usepackage{amsmath}
\input{spAMALatexPkg.tex}
\input{spAMALatexDefn.tex}
\usepackage{fancyheadings}
\usepackage{moreverb}
\usepackage{rotating}
\usepackage{amssymb}

\title{A ``C'' Implementation of \\ the Anderson-Moore Algorithm\\
Employing Sparse Matrix Techniques\\sparseAMA.c}
\author{Gary S. Anderson\thanks{Ralph Tryon contributed many useful modifications and corrections.}}

\begin{document}
\maketitle
\begin{abstract}
  This code implements the Anderson-Moore algorithm for solving
 linear saddle-point problems.


The Anderson-Moore Algorithm is a powerful method for 
solving linear saddle point
 models. The algorithm has proven useful in a wide array of 
applications, including
 analyzing linear perfect-foresight models and 
providing initial solutions and
 asymptotic constraints for nonlinear models. The algorithm 
solves linear problems with
 dozens of lags and leads and hundreds of equations in seconds. 

The original implementation of the
algorithm exploited aspects of the inherent
sparsity of the linear systems that alternative approaches
cannot. However, incorporating sparse matrix storage and linear
algebraic routines dramatically improves the scalability of this implementation.

\end{abstract}
\newpage
\pagenumbering{arabic}
\part{Introduction}
\section{How to Use this Document}
\label{sec:how}
This document contains information for both the casual user and the developer.
A casual user will probably only need to consult Part \ref{prt:userInfo}.

%\subsection{Reading the Documentation}
By applying the program {\bf nuweb} to the source file,
 a maintainer/developer can generate
both the program and documentation.
{\bf nuweb } generates and presents programs by identifying small pieces
of code called {\bf scraps} and assembling these named scraps into
larger structures.

For example, the description of the main routine beginning 
on page \pageref{simpleMain}
in section \ref{simpleMain}.
One can use the number in the just before the left angle bracket to locate
the text defining the scrap.






\section{Problem Statement and Algorithm Overview}

\subsection{Unconstrained Autoregression}
\label{sec:unconstrainedar}


Anderson and Moore \cite{ANDER:AIM2} outlines a procedure that computes solutions for structural models of the form
\begin{gather}
\sum_{i= - \tau}^\theta { H_i ~ x_{ t + i } }= 0~,~ t \geq 0 \label{eq:canonical}\\ \intertext{ with initial conditions, if any, given by constraints of the form}
x_t ~ = ~ x^{data}_t ~ , ~ t = ~ - \tau~, \ldots ,~ -1\\ \intertext{where both $\tau$ and $\theta$ are non-negative, and $x_t$ is an L dimensional vector with}
\lim_{ t \rightarrow \infty } x_t ~ = ~ 0
\end{gather}

The algorithm determines whether
the model \ref{eq:canonical} has a unique solution, an infinity of
 solutions or no solutions at all.

The specification \ref{eq:canonical} is not restrictive.
One can handle inhomogeneous version  of equation \ref{eq:canonical}
by recasting the problem in terms of  deviations from a steady state value or
by adding a new variable for each non-zero right hand side with an equation
guaranteeing the  value always equals  
the inhomogeneous value($x^{con}_t =x^{con}_{t-1}$ and $x^{con}_{t-1} = x^{RHS}$).



Saddle point problems combine initial conditions and asymptotic 
convergence to identify their solutions.
The uniqueness of solutions to 
system  \ref{eq:canonical} requires that
the transition matrix characterizing the linear system have an appropriate
number of explosive and stable eigenvalues\cite{blanchard80},
and that the asymptotic linear constraints 
are linearly independent of explicit and implicit initial 
conditions\cite{ANDER:AIM2}.

The solution methodology entails 
\begin{enumerate}
\item using equation \ref{eq:canonical} to
compute a state space transition matrix.
\item Computinging the eigenvalues and the invariant space associated with
large eigenvalues
\item Combining the constraints provided by:
  \begin{enumerate}
  \item the
initial conditions,
\item  auxiliary initial conditions identified in the computation of the transisiton matrix and 
\item the invariant space vectors
  \end{enumerate}
\end{enumerate}

Figure \ref{fig:overview} presents a flow chart  summarizing the
algorithm. 
%For a description of a parallel implementation see \cite{ANDER:PARA}
%For a description of a continuous application see \cite{anderson97}.

\begin{figure}[htbp]
  \begin{center}
\includegraphics[width=8cm]{overallGraph.pdf}
%   \caption{Algorithm Overview}
    \label{fig:overview}
  \end{center}
\end{figure}

%Anderson and Moore \cite{ANDER:AIM2} demonstrates that 



%Given the coefficient matrix
%\begin{gather*}
%\matob{H_{-\tau}}{H_\theta}
%\end{gather*}
%the procedure computes the reduced form coefficient matrix
%\begin{gather*}
%\matob{B_{-\tau}}{ B_{-1}}
%\end{gather*}
%for any model satisfying assumptions \ref{asmone} and \ref{asmtwo}.  If the model does not satisfy assumptions \ref{asmone} and \ref{asmtwo}, the procedure indicates whether there are no convergent solutions or a multiplicity of convergent solutions.



  

\NumberProgramstrue
\sfvariables
\begin{algrthm}
\label{alg:unconstrainedAR}
\begin{program}
\mbox{Given $H$, compute the unconstrained auto-regression.} 
\FUNCT \mathcal{F}_{\ref{alg:unconstrainedAR}}(H) \BODY
k:=0
\mathcal{Z}^0:=\varnothing
\mathcal{H}^0:=H
\WHILE \mathcal{H}^k_\theta \text{ is singular } \cap rows(\mathcal{Z}^k) < L(\tau+\theta) 
\DO
U^k=\begin{bmatrix}U^k_Z\\U^k_N\end{bmatrix}:=|rowAnnihilator|(\mH^k_\theta)
\mH^{k+1}:= \longExpH
\mZ^{k+1}:= \longExpQ
k:=k+1
\OD
|return| \{ \begin{bmatrix}\mH^k_-\tau&\ldots&\mH^k_{\theta}\end{bmatrix},(\Gamma \text{ or } \varnothing),\mZ^k \}
\ENDFUNCT
\end{program}
\end{algrthm}

{\color{anewcolor}
\begin{thrm}
Let 
{\small
\begin{gather*} \mathcal{H}=\left .
  \begin{bmatrix}
\hmats\\
&\hmats\\
&&\ddots\\
&&&\hmats\\
&&&&\hmats\\
  \end{bmatrix} \right \} \text{${\scriptstyle\tau+\theta+1}$} 
\end{gather*}}
There are two cases:
\begin{enumerate}
\item When $\mathcal{H}$ is full rank the algorithm terminates with 
 $Z^{\sharp\ast}$($Z^{\flat\ast}$) and non-singular
 $H^{\sharp\ast}_{\theta}$($H^{\flat\ast}_{\tau}$)
\item When $\mathcal{H}$ is not full rank the algorithm terminates when
some row of $
\begin{bmatrix}
\mathcal{H}^k_{-\tau}\ldots\mathcal{H}^k_\theta 
\end{bmatrix}$ is zero.
\end{enumerate}

\end{thrm}
}




\subsection{Invariant Space Calculations}
\label{sec:invariantSpace}


\begin{thrm}
Let $\{x^{conv}_t\}$, $t= -\tau,\ldots,\infty$ be a non explosive solution satisfying
equation \ref{eq:canonical}. Let $A$ be the state space transition matrix
for equation
\ref{eq:canonical} and $V$ be a set of
invariant space vectors spanning the invariant space
associated with roots of
$A$ of magnitude bigger than $1$. Then for $t= 0,\ldots,\infty$
\begin{gather*}
V 
\begin{bmatrix}
  x^{conv}_{t-\tau}\\
\vdots\\
  x^{conv}_{t+\theta-1}
\end{bmatrix}=0
\end{gather*}
\end{thrm}
\begin{crrlry}
Let $\{x_t\}$, $t= -\tau,\ldots,\infty$ be a  solution satisfying
equation \ref{eq:canonical}.  If $A$ has no roots with magnitude $1$ then the 
path converges to the
unique steady state if and only if
\begin{gather*}
V 
\begin{bmatrix}
  x_{t-\tau}\\
\vdots\\
  x_{t+\theta-1}
\end{bmatrix}=0
\end{gather*}
for some $t$.
\end{crrlry}
\begin{crrlry}
  If $A$ has roots with magnitude $1$ then a path converges to 
a limit cycle(or fixed point)  if and only if
\begin{gather*}
V 
\begin{bmatrix}
  x_{t-\tau}\\
\vdots\\
  x_{t+\theta-1}
\end{bmatrix}=0
\end{gather*}
for some $t$.
\end{crrlry}
\begin{algrthm}
\label{alg:invariantSpace}
\begin{program}
\mbox{Given $ \Gamma^{\sharp,\ast},Z^{\sharp,\ast},Z^{\flat,\ast} $,}
\mbox{compute vectors spanning the left invariant }
\mbox{space associated with large eigenvalues}
\FUNCT \mathcal{F}_{\ref{alg:invariantSpace}}( \Gamma^{\sharp,\ast},Z^{\sharp,\ast},Z^{\flat,\ast})
A:=\begin{bmatrix}\begin{matrix}  0&I\end{matrix}\\ \Gamma^\sharp\end{bmatrix}
\{\bar{A},\Pi,J_0\}=|stateSpaceReducer|( A,Z^{\sharp,\ast},Z^{\flat,\ast} )
\{\bar{V},M\}:=|leftInvariantSpaceVectors|(\bar{A})
V=|stateSpaceExpander|(\bar{V},M,\Pi,J_0)
\ENDFUNCT
\end{program}
\end{algrthm}
\begin{thrm}
  
Let
\begin{gather*}
  Q= 
  \begin{bmatrix}
    Z^{\sharp}\\V
  \end{bmatrix}
= 
  \begin{bmatrix}
    Q_L&Q_R
  \end{bmatrix}
\end{gather*}
The existence of convergent solutions depends on the magnitude of the
rank of the augmented
matrix 
\begin{gather*}
r_1=rank \left (  
\begin{bmatrix}
    I&0&x_{data}\\
Q_L&Q_R&0
  \end{bmatrix} 
\right ) 
\\ 
\intertext{ and  }
r_2=rank \left (  \begin{bmatrix}
    I&0\\
Q_L&Q_R
  \end{bmatrix} \right )
\end{gather*}
and  $L(\tau+\theta)$, the number of unknowns.


\begin{enumerate}
\item If $r_1 > r_2$ there is no nontrivial convergent solution
\item If $r_1 = r_2 = L(\tau + \theta)$ there is a unique convergent solution
\item If $r_1 = r_2 < L(\tau + \theta)$ the system has an infinity of convergent 
solutions
\end{enumerate}

\end{thrm}


\begin{crrlry}
  When $Q$ has $L \theta$ rows, $Q_R$ is square.
If  $Q_R$ is non-singular, the system has a unique solution and
\begin{gather*}
    \begin{bmatrix}
    B\\B_2\\ \vdots \\ B_{\theta}  
  \end{bmatrix}
= Q_R^{-1} Q_L
\end{gather*}
  If $Q_R$ is singular, the system has an infinity of solutions.
\end{crrlry}
\begin{crrlry}
  When $Q$ has fewer than $L \theta$ rows,
The system has an infinity of solutions.
\end{crrlry}
\begin{crrlry}
  When $Q$ has more than $L \theta$ rows,
The system has a unique nontrivial 
solution only for specific values of $x_{data}$
\end{crrlry}

\begin{algrthm}
\label{alg:asymptoticConstraints}
\begin{program}
\mbox{Given $V,Z^{\sharp,\ast}$,}
\FUNCT \mathcal{F}_{\ref{alg:asymptoticConstraints}}(V,Z^{\sharp,\ast})
Q:=\begin{bmatrix}Z^{\sharp,\ast}\\V\end{bmatrix}
|cnt|=noRows(Q)
|return|\begin{cases}
\{Q,\infty\} &|cnt| < L\theta 
\{Q,0\} &|cnt| > L\theta 
\{Q,\infty\}&(Q_R singular) 
\{-Q_R^{-1} Q,1\} &otherwise
\end{cases}
\ENDFUNCT
\end{program}
\end{algrthm}


\newpage
\part{User Information}
\label{prt:userInfo}
\section{The sparseAim Program}


\newpage
\part{Maintainer and Developer  Information}
\section{Development Notes}

\subsection{Package Library Dependencies}
\label{sec:pkg}

Developer's note the program uses several FORTRAN
libraries available on the INTERNET:


\subsubsection{ SPARSKIT2}

\label{sec:sparskit}
Appendix \ref{spasemacros} identifies the macros that provide an interface
to the sparse linear algebra routines. 
The code uses ``SPARSKIT: A basic toolkit for sparse matrix computations'' Version 2. ( available from http://www.cs.umn.edu/Research/arpa/SPARSKIT/sparskit.html). One can redefine the macros to use an alternative linear algebra
package.

Yousef Saad writes:
\begin{quote}
  IMPORTANT: 


Copyright 1990, 1994 Yousef Saad.

Permission to copy all or  part of any  material contained in SPARSKIT
is only  granted upon approval from Yousef  Saad.  Not  any portion of
SPARSKIT can   be used  for  commercial  purposes  or  as  part of   a
commercial package.  This notice should accompany   the package in any
approved copy.



\end{quote}




 http://www.cs.umn.edu/Research/arpa/SPARSKIT/sparskit.html
In particular, the code uses the following routines:
copmat, filter, submat, amub, rperm, cperm, getdia, diamua, usol and cnrms.
The SPARSKIT author requires that the 
following statement accompany any code using SPARSKIT:

\begin{verbatim}
-----------------------------------------------------------------------
                   S P A R S K I T   V E R S I O N  2.
----------------------------------------------------------------------- 

Latest update : Thu Nov 20 09:24:38 CST 1997

-----------------------------------------------------------------------

IMPORTANT: 
---------- 

Copyright 1990,1994 Yousef Saad.
------------------------------------ 

Permission to copy all or  part of any  material contained in SPARSKIT
is only  granted upon approval from Yousef  Saad.  Not  any portion of
SPARSKIT can   be used  for  commercial  purposes  or  as  part of   a
commercial package.  This notice should accompany   the package in any
approved copy.

Note to contributors: Before  contributing any software be aware  that
above  note     is   the only    global  limitation    against copying
software. Eventually this copyright note may be replaced.

DISCLAIMER
----------

SPARSKIT comes  with no warranty whatsoever.   The author/contributors
of SPARKSIT are not liable for any loss/damage or inconvenience caused
in  the use of the software  in  SPARSKIT or any modification thereof.


\end{verbatim}
\subsubsection{ LAPACK 3.0}


\label{sec:lapack}


\begin{quote}
  
LAPACK is a library of Fortran 77 subroutines for solving
the most commonly occurring problems in numerical linear algebra.
It is public-domain software, and can be used freely.

LAPACK is available via netlib, anonymous ftp, world wide web, and a
tar tape from NAG.

The tar tape contains the Fortran source for LAPACK, the testing programs, and
the timing programs.

It also contains Fortran code for the Basic Linear Algebra Subprograms
(the Level 1, 2, and 3 BLAS) needed by LAPACK.
However this code is intended for use only if there is no other implementation
of the BLAS already available on your machine; the efficiency of LAPACK
depends very much on the efficiency of the BLAS.

The complete package, including test code and timing programs in four
different Fortran data types (real, complex, double precision, double
complex), contains some 735,000 lines of Fortran source and comments.
You will need approximately 33 Mbytes to read the complete tape.
We recommend that you run the testing and timing programs.
The total space requirements for the testing and timing for all four data
types, including the object files, is approximately 80 Mbytes.
\end{quote}



 http://www.netlib.org/lapack/
DGEES, DGEQPF and supporting routines. The website provides the following information
regarding availability.
\begin{quote}


LAPACK is a freely-available software package. 
It is available from netlib via anonymous ftp and the World Wide Web. 
Thus, it can be included in
commercial software packages (and has been). 
We only ask that proper credit be given to the authors.

Like all software, it is copyrighted. 
It is not trademarked, but we do ask the following:

If you modify the source for these routines we ask that 
you change the name of the routine and comment the changes 
made to the original.

We will gladly answer any questions regarding the software. 
If a modification is done, however, 
it is the responsibility of the person who modified the
routine to provide support.
\end{quote}
%\end{abstract}




\subsection{Known Bugs}
\label{sec:knownbugs}


\subsection{Things To Do}
\label{sec:thingtodo}
\begin{description}
\item[satisfiesLinearSystemQ] \ 
  \begin{itemize}
\item include eigenvalue calculation in solution checker
\item compare rowsInQ to expected result
\item return value from satisfiesLinearSystemQ
  \end{itemize}
\item[Miscellaneous Features] \ 
  \begin{itemize}
\item clean up makefiles
\item chart future
\item Trap common mistakes
\item verbose and silent modes
\item progress monitor
\item modify argument list int in int out double in double out
\item verbose and silent versions
\item Windows installation(.zip compilers)
\item condition number for overall calculation
\item improve ``helpfulness'' of error messages
  \end{itemize}
\item[Robustness] \ 
  \begin{itemize}
  \item optimize scaling of H and or Q rows
\item valid csr should check null allocation
\item reconocile non-negative leads and req of positive constraintsNeeded(ie handle models with no lags and no leads)
  \end{itemize}
\item[Extensions] \ 
  \begin{itemize}
\item mathlink sparse aim
\item obstruct computations
\item asymptotic covariance computations
\item validate applySparseReducedForm
\item compute phi and F and S
\item IDL for corba
\item RMI interface
  \end{itemize}
\item[Performance Enhancements] \ 
  \begin{itemize}
\item do timing tests 
\item gprof linear aim
\item toggle out assertion checking with option or compile
\item arpack
\item jump start for shiftrights
\item jump start for arpack
  \end{itemize}
\end{description}
\section{Installing the Library}

\subsection{An Example Makefile}
\label{sec:examplelibmake}
\section{The Code}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap1}\raggedright\small
\NWtarget{nuweb14}{} \verb@"devsparseAMA.c"@\nobreak\ {\footnotesize {14}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@#include "useSparseAMA.h"@\\
\mbox{}\verb@#ifdef WIN32@\\
\mbox{}\verb@#include <time.h>@\\
\mbox{}\verb@#else@\\
\mbox{}\verb@#include <time.h>@\\
\mbox{}\verb@#include <sys/time.h>@\\
\mbox{}\verb@#endif@\\
\mbox{}\verb@double ZERO_TOLERANCE;@\\
\mbox{}\verb@double ZERO_TOL1;@\\
\mbox{}\verb@unsigned int USEARPACK, TESTBLANCHARDKAHN ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define BADRC 99u@\\
\mbox{}\verb@#define cputime() (( (double)clock() ) / CLOCKS_PER_SEC)@\\
\mbox{}\verb@double totcpusec, tmpcpusec, oldcpusec, alloc_sec, assert_sec, qr_sec ;@\\
\mbox{}\verb@unsigned int  alloc_count, assert_count, qr_count ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@double time_rightMostAllZeroQ, time_rmazq_alloc ;@\\
\mbox{}\verb@unsigned int count_rightMostAllZeroQ, count_constructA, count_useArpack, count_dgees ;@\\
\mbox{}\verb@double time_constructQRDecomposition, time_sparseMult, time_arpack, time_sparseMatTimesVec ;@\\
\mbox{}\verb@double time_extract, time_backsolve ;@\\
\mbox{}\verb@double time_autoregression, time_augmentQ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb14}{14}\NWlink{nuweb15}{, 15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17}{, 17}\NWlink{nuweb18}{, 18}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap2}\raggedright\small
\NWtarget{nuweb15}{} \verb@"devsparseAMA.c"@\nobreak\ {\footnotesize {15}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* ----------------------------------------------------------------- */@\\
\mbox{}\verb@/* misc utility routines follow ...                                  */@\\
\mbox{}\verb@/*                                                                   */@\\
\mbox{}\verb@/*                                                                   */@\\
\mbox{}\verb@/*  lineNumberToViolation                                            */@\\
\mbox{}\verb@/*  lineNumberToString                                               */@\\
\mbox{}\verb@/*  validVector                                                      */@\\
\mbox{}\verb@/*  validCSRMatrix                                                   */@\\
\mbox{}\verb@/*  cPrintMatrix                                                     */@\\
\mbox{}\verb@/*  cPrintMatrixNonZero                                              */@\\
\mbox{}\verb@/*  cPrintSparse                                                     */@\\
\mbox{}\verb@/*  rowEndsInZeroBlock                                               */@\\
\mbox{}\verb@/*                                                                   */@\\
\mbox{}\verb@/* ----------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@static int lineNumberToViolation(unsigned int lineNo)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@unsigned int result;@\\
\mbox{}\verb@switch(lineNo)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@case  sparseAMAPreMaxNumberOfHElementsLEZero: result=@\\
\mbox{}\verb@  sparseAMA_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  sparseAMAPreHrows: result=@\\
\mbox{}\verb@  sparseAMA_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  sparseAMAPreHcolsHrows: result=@\\
\mbox{}\verb@  sparseAMA_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  sparseAMAPreLeads: result=@\\
\mbox{}\verb@  sparseAMA_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  sparseAMAPreHmat: result=@\\
\mbox{}\verb@  sparseAMA_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  sparseAMAPreAuxRows: result=@\\
\mbox{}\verb@  sparseAMA_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  sparseAMAPreRowsInQ: result=@\\
\mbox{}\verb@  sparseAMA_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  sparseAMAPreQmat: result=@\\
\mbox{}\verb@  sparseAMA_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  autoRegressionPostValidQ: result=@\\
\mbox{}\verb@  autoRegression_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  autoRegressionPostValidH: result=@\\
\mbox{}\verb@  autoRegression_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  autoRegressionPostValidAnnihilator: result=@\\
\mbox{}\verb@  autoRegression_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  autoRegressionPostValidR: result=@\\
\mbox{}\verb@  autoRegression_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  autoRegressionPostValidJs: result=@\\
\mbox{}\verb@  autoRegression_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPreConstraints: result=@\\
\mbox{}\verb@  augmentQmatWithInvariantSpaceVectors_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPreAuxiliary: result=@\\
\mbox{}\verb@  augmentQmatWithInvariantSpaceVectors_PRECONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidQ: result=@\\
\mbox{}\verb@  augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidRealRoot: result=@\\
\mbox{}\verb@  augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidImagRoot: result=@\\
\mbox{}\verb@  augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidA: result=@\\
\mbox{}\verb@  augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostADim: result=@\\
\mbox{}\verb@  augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidJs: result=@\\
\mbox{}\verb@  augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case  shiftRightAndRecordPreZeroRow: result=@\\
\mbox{}\verb@  STACKED_SYSTEM_NOT_FULL_RANK; break;@\\
\mbox{}\verb@case  annihilateRowsPostValidH: result=@\\
\mbox{}\verb@  annihilateRows_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case nzmaxTooSmallConstructA: result=@\\
\mbox{}\verb@  HELEMS_TOO_SMALL; break;@\\
\mbox{}\verb@case nzmaxTooSmallAugmentQ: result=@\\
\mbox{}\verb@  HELEMS_TOO_SMALL; break;@\\
\mbox{}\verb@case nzmaxTooSmallAnnihilateRows: result=@\\
\mbox{}\verb@  HELEMS_TOO_SMALL; break;@\\
\mbox{}\verb@case ndnsTooSmall: result=@\\
\mbox{}\verb@  AMAT_TOO_LARGE; break;@\\
\mbox{}\verb@case qextentTooBig: result=@\\
\mbox{}\verb@  HELEMS_TOO_SMALL; break;@\\
\mbox{}\verb@case errorReturnFromUseArpack: result=@\\
\mbox{}\verb@  augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED; break;@\\
\mbox{}\verb@case tooManyLargeRoots: result=@\\
\mbox{}\verb@  TOO_MANY_LARGE_ROOTS; break;@\\
\mbox{}\verb@case tooFewLargeRoots: result=@\\
\mbox{}\verb@  TOO_FEW_LARGE_ROOTS; break;@\\
\mbox{}\verb@default: result=@\\
\mbox{}\verb@  99;break;@\\
\mbox{}\verb@}@\\
\mbox{}\verb@return(result);@\\
\mbox{}\verb@}@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@static char * lineNumberToString(int lineNo)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@char * result;@\\
\mbox{}\verb@switch(lineNo)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@case  sparseAMAPreMaxNumberOfHElementsLEZero: result=@\\
\mbox{}\verb@  "sparseAMA_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  sparseAMAPreHrows: result=@\\
\mbox{}\verb@  "sparseAMA_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  sparseAMAPreHcolsHrows: result=@\\
\mbox{}\verb@  "sparseAMA_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  sparseAMAPreLeads: result=@\\
\mbox{}\verb@  "sparseAMA_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  sparseAMAPreHmat: result=@\\
\mbox{}\verb@  "sparseAMA_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  sparseAMAPreAuxRows: result=@\\
\mbox{}\verb@  "sparseAMA_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  sparseAMAPreRowsInQ: result=@\\
\mbox{}\verb@  "sparseAMA_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  sparseAMAPreQmat: result=@\\
\mbox{}\verb@  "sparseAMA_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  autoRegressionPostValidQ: result=@\\
\mbox{}\verb@  "autoRegression_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  autoRegressionPostValidH: result=@\\
\mbox{}\verb@  "autoRegression_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  autoRegressionPostValidAnnihilator: result=@\\
\mbox{}\verb@  "autoRegression_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  autoRegressionPostValidR: result=@\\
\mbox{}\verb@  "autoRegression_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  autoRegressionPostValidJs: result=@\\
\mbox{}\verb@  "autoRegression_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPreConstraints: result=@\\
\mbox{}\verb@  "augmentQmatWithInvariantSpaceVectors_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPreAuxiliary: result=@\\
\mbox{}\verb@  "augmentQmatWithInvariantSpaceVectors_PRECONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidQ: result=@\\
\mbox{}\verb@  "augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidRealRoot: result=@\\
\mbox{}\verb@  "augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidImagRoot: result=@\\
\mbox{}\verb@  "augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidA: result=@\\
\mbox{}\verb@  "augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostADim: result=@\\
\mbox{}\verb@  "augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  augmentQmatWithInvariantSpaceVectorsPostValidJs: result=@\\
\mbox{}\verb@  "augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case  shiftRightAndRecordPreZeroRow: result=@\\
\mbox{}\verb@  "STACKED_SYSTEM_NOT_FULL_RANK"; break;@\\
\mbox{}\verb@case  annihilateRowsPostValidH: result=@\\
\mbox{}\verb@  "annihilateRows_POSTCONDITIONS_VIOLATED"; break;@\\
\mbox{}\verb@case nzmaxTooSmallConstructA: result=@\\
\mbox{}\verb@  "maxNumberOfHElementsTooSmall"; break;@\\
\mbox{}\verb@case nzmaxTooSmallAnnihilateRows: result=@\\
\mbox{}\verb@  "maxNumberOfHElementsTooSmall"; break;@\\
\mbox{}\verb@case nzmaxTooSmallAugmentQ: result=@\\
\mbox{}\verb@  "nzmaxTooSmallAugmentQ"; break;@\\
\mbox{}\verb@case ndnsTooSmall: result=@\\
\mbox{}\verb@  "transitionMatrixTooSmall"; break;@\\
\mbox{}\verb@case qextentTooBig: result=@\\
\mbox{}\verb@  "maxNumberOfHElementsTooSmall"; break;@\\
\mbox{}\verb@case errorReturnFromUseArpack: result=@\\
\mbox{}\verb@  "unable to compute eigenvalues using ARPACK"; break;@\\
\mbox{}\verb@case tooManyLargeRoots: result=@\\
\mbox{}\verb@  "Blanchard-Kahn fails:  too many large roots" ; break;@\\
\mbox{}\verb@case tooFewLargeRoots: result=@\\
\mbox{}\verb@  "Blanchard-Kahn fails:  too few large roots" ; break;@\\
\mbox{}\verb@default: result=@\\
\mbox{}\verb@  "unknown assertion violation";break;@\\
\mbox{}\verb@}@\\
\mbox{}\verb@return(result);@\\
\mbox{}\verb@}@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@int validVector(unsigned int numRows,double * vec)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@  unsigned int i;@\\
\mbox{}\verb@int allFiniteNumbers;@\\
\mbox{}\verb@      allFiniteNumbers=TRUE;@\\
\mbox{}\verb@      for(i=0;i<numRows;i++){@\\
\mbox{}\verb@        allFiniteNumbers=(isfinite(vec[i])&&allFiniteNumbers);}@\\
\mbox{}\verb@@\\
\mbox{}\verb@      return(allFiniteNumbers);@\\
\mbox{}\verb@}@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@unsigned int validCSRMatrix( unsigned int numRows,double * mata,unsigned int * matj,unsigned int *mati)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@  unsigned int i;unsigned int result,allPositive,elements,allFiniteNumbers;@\\
\mbox{}\verb@elements=mati[numRows]-mati[0];@\\
\mbox{}\verb@result=@\\
\mbox{}\verb@  (mati[numRows]>0) && (mati[0]>0) && (@\\
\mbox{}\verb@          (elements) >=0);@\\
\mbox{}\verb@      allPositive=TRUE;@\\
\mbox{}\verb@      for(i=0;i<numRows;i++){allPositive=(mati[i]>0&&allPositive);}@\\
\mbox{}\verb@      result=@\\
\mbox{}\verb@        (result && allPositive);@\\
\mbox{}\verb@      allPositive=TRUE;@\\
\mbox{}\verb@      for(i=0;i<elements;i++){@\\
\mbox{}\verb@        allPositive=(matj[i]>0&&allPositive);}@\\
\mbox{}\verb@      allFiniteNumbers=TRUE;@\\
\mbox{}\verb@      for(i=0;i<elements;i++){@\\
\mbox{}\verb@        allFiniteNumbers=(isfinite(mata[i])&&allFiniteNumbers);}@\\
\mbox{}\verb@@\\
\mbox{}\verb@      result=@\\
\mbox{}\verb@        (result && allPositive && allFiniteNumbers);@\\
\mbox{}\verb@      return(result);@\\
\mbox{}\verb@}@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@void cPrintMatrix(unsigned int nrows,unsigned int ncols,double * matrix)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@unsigned int i,j;@\\
\mbox{}\verb@for(i=0;i<nrows;i++)@\\
\mbox{}\verb@for(j=0;j<ncols;j++)printf("[%d] [%d] %f\n",i,j,matrix[i+(j*nrows)]);@\\
\mbox{}\verb@}@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@void cPrintMatrixNonZero(unsigned int nrows,unsigned int ncols,double *matrix,double zerotol)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@unsigned int i,j;@\\
\mbox{}\verb@double fabs(double x);@\\
\mbox{}\verb@for(i=0;i<nrows;i++)@\\
\mbox{}\verb@for(j=0;j<ncols;j++)@\\
\mbox{}\verb@    if(fabs(matrix[i+(j*nrows)]) > zerotol)@\\
\mbox{}\verb@    printf("[%d] [%d] %f\n",i,j,matrix[i+(j*nrows)]);@\\
\mbox{}\verb@}@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@void cPrintSparse(unsigned int rows,double * a,unsigned int * aj,unsigned int * ai)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@unsigned int i,j,numEls;@\\
\mbox{}\verb@numEls=ai[rows]-ai[0];@\\
\mbox{}\verb@printf("matrix has %d non zero element/s\n",numEls);@\\
\mbox{}\verb@for(i=0;i<rows;i++)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@for(j=ai[i];j<ai[i+1];j++)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@printf("row=%d,col=%d,val=%f\n",i+1,aj[j-1],a[j-1]);@\\
\mbox{}\verb@}}@\\
\mbox{}\verb@}@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*int rowEndsInZeroBlock() ;*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* ----------------------------------------------------------------------@\\
\mbox{}\verb@ rowEndsInZeroBlock (targetRow, blockLength, mat, matj, mati, ncols)@\\
\mbox{}\verb@@\\
\mbox{}\verb@ returns true if targetRow in CSR matrix mat ends in zero block,@\\
\mbox{}\verb@ else returns false@\\
\mbox{}\verb@@\\
\mbox{}\verb@        targetRow               row number to check@\\
\mbox{}\verb@        blockLength             length of block to check@\\
\mbox{}\verb@        mat, matj, mati         target matrix in CSR format@\\
\mbox{}\verb@        ncols                           number of columns in 'mat'@\\
\mbox{}\verb@@\\
\mbox{}\verb@ notes@\\
\mbox{}\verb@ no range checking -- targetRow and blockLength are assumed to be in bounds@\\
\mbox{}\verb@---------------------------------------------------------------------- */@\\
\mbox{}\verb@int rowEndsInZeroBlock (@\\
\mbox{}\verb@ unsigned       int targetRow,@\\
\mbox{}\verb@unsigned        int blockLength,@\\
\mbox{}\verb@        double *mat,@\\
\mbox{}\verb@unsigned        int *matj,@\\
\mbox{}\verb@unsigned        int *mati,@\\
\mbox{}\verb@unsigned        int ncols@\\
\mbox{}\verb@) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@unsigned        int i ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* loop through nonzeros for this row */@\\
\mbox{}\verb@        for (i=mati[targetRow-1]; i<mati[targetRow]; i++) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* if column index for this value is inside block,@\\
\mbox{}\verb@               we have a nonzero value, so return false */@\\
\mbox{}\verb@                if (matj[i-1]>(ncols-blockLength) && matj[i-1]<=ncols)@\\
\mbox{}\verb@                        return (0) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* no nonzeros found, return true */@\\
\mbox{}\verb@        return (1) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@}@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* ----------------------------------------------------------------------@\\
\mbox{}\verb@ deleteRow (targetRow, mat, nrows, ncols)@\\
\mbox{}\verb@@\\
\mbox{}\verb@        deletes row targetRow from dense matrix mat, which is nrows by ncols@\\
\mbox{}\verb@        deletes in place, last row of existing matrix is left unchanged@\\
\mbox{}\verb@        returns 0 if successful@\\
\mbox{}\verb@        targetRow is indexed from 1 to nrows@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@---------------------------------------------------------------------- */@\\
\mbox{}\verb@int deleteRow (unsigned int targetRow, double *mat,unsigned  int nrows,unsigned  int ncols) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@unsigned int i, istart, istop ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* if targetRow is out of bounds, print msg and return */@\\
\mbox{}\verb@        if (targetRow < 1 || targetRow > nrows) {@\\
\mbox{}\verb@                printf ("deleteRow:  target row %d is out of bounds\n", targetRow) ;@\\
\mbox{}\verb@                return (-1) ;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* start with first value of row to be deleted */@\\
\mbox{}\verb@        istart = (targetRow-1)*ncols ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* stop and beginning of last row */@\\
\mbox{}\verb@        istop = (nrows-1)*ncols ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* copy data from one row ahead */@\\
\mbox{}\verb@        for (i=istart; i<istop; i++)@\\
\mbox{}\verb@                mat[i] = mat[i+ncols] ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* all done */@\\
\mbox{}\verb@        return (0) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* deleteRow */@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*not static because mathLink code uses these*/@\\
\mbox{}\verb@int discreteSelect(double * realPart,double * imagPart){@\\
\mbox{}\verb@        return((*realPart* *realPart)+(*imagPart* *imagPart)>1+ (ZERO_TOL1));@\\
\mbox{}\verb@}@\\
\mbox{}\verb@int continuousSelect(double * realPart,double * imagPart){@\\
\mbox{}\verb@        return(*realPart>ZERO_TOLERANCE);@\\
\mbox{}\verb@}@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !shiftRighttAndRecord                                           */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* -----------------------------------------------------------------------------@\\
\mbox{}\verb@@\\
\mbox{}\verb@        shift rows of H right one block at a time until no row ends in a zero block.@\\
\mbox{}\verb@        for each shift, add row to Q to form auxiliary initial conditions.@\\
\mbox{}\verb@        return total number of rows in Q.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        arguments@\\
\mbox{}\verb@@\\
\mbox{}\verb@                maxNumberOfHElements            space allocated for Q matrix@\\
\mbox{}\verb@                returnCode                                      used by sparseAMAAssert@\\
\mbox{}\verb@                dim                                             number of columns in block to check for zero@\\
\mbox{}\verb@                rowsInQ                                         number of rows in Q matrix@\\
\mbox{}\verb@                qmat, qmatj, qmati                      Q matrix in CSR format@\\
\mbox{}\verb@                hrows, hcols                            number of rows, columns in H matrix@\\
\mbox{}\verb@                hmat, hmatj, hmati                      H matrix in CSR format@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@----------------------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@static unsigned int shiftRightAndRecord (@\\
\mbox{}\verb@        unsigned int *maxNumberOfHElements,@\\
\mbox{}\verb@    unsigned int *returnCode,@\\
\mbox{}\verb@unsigned     int dim,@\\
\mbox{}\verb@unsigned int rowsInQ,@\\
\mbox{}\verb@    double * qmat,unsigned int * qmatj,unsigned int * qmati,@\\
\mbox{}\verb@unsigned     int hrows,unsigned int hcols,@\\
\mbox{}\verb@    double * hmat,unsigned int * hmatj,unsigned int * hmati@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@unsigned        int i, j, qextent, zeroRow ;@\\
\mbox{}\verb@        static unsigned int maxHElementsEncountered=0;          /* bumpSparseAMA */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* check for zero rows in H matrix -- can't shift right if all zeros */@\\
\mbox{}\verb@        /* (if row has no nonzero values, adjacent row pointers will be equal) */@\\
\mbox{}\verb@        zeroRow=FALSE;@\\
\mbox{}\verb@        i = 1 ;@\\
\mbox{}\verb@        while (i <= hrows && !zeroRow) {@\\
\mbox{}\verb@                zeroRow = (hmati[i-1]==hmati[i]) ;@\\
\mbox{}\verb@                i++ ;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@    sparseAMAAssert (zeroRow==FALSE, shiftRightAndRecordPreZeroRow);@\\
\mbox{}\verb@        if (*returnCode) return (BADRC) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* keep track of space used in Q */@\\
\mbox{}\verb@        qextent=qmati[rowsInQ]-qmati[0];@\\
\mbox{}\verb@        bumpSparseAMA((qextent));@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* loop through rows of H */@\\
\mbox{}\verb@        for(i=1; i<=hrows; i++) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* while row ends in zero block, add row to Q and shift right in H */@\\
\mbox{}\verb@                while (rowEndsInZeroBlock(i, dim, hmat, hmatj, hmati, hcols)) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* add a row to Q */@\\
\mbox{}\verb@                        rowsInQ ++ ;@\\
\mbox{}\verb@                        qmati[rowsInQ-1]=qextent+1;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* loop through nonzeros in this row of H */@\\
\mbox{}\verb@                        for(j=hmati[i-1]; j<hmati[i]; j++){@\\
\mbox{}\verb@@\\
\mbox{}\verb@                                /* copy H value into Q */@\\
\mbox{}\verb@                                qmat[qextent]=hmat[j-1];@\\
\mbox{}\verb@                                qmatj[qextent]=hmatj[j-1];@\\
\mbox{}\verb@                                qextent++;@\\
\mbox{}\verb@                   @\\
\mbox{}\verb@                       /* make sure we've got enough space (tighten up vis-a-vis original) */@\\
\mbox{}\verb@                                /* sparseAMAAssert((qextent <= *maxNumberOfHElements+1), qextentTooBig); */@\\
\mbox{}\verb@                                sparseAMAAssert((qextent < *maxNumberOfHElements), qextentTooBig);@\\
\mbox{}\verb@                                if (*returnCode) return (BADRC) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                                /* shift H value right one block.  (Zeros are just ignored.) */@\\
\mbox{}\verb@                                hmatj[j-1] += dim;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        }@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* keep track of space used in Q */@\\
\mbox{}\verb@        qmati[rowsInQ]=qextent+1;@\\
\mbox{}\verb@        bumpSparseAMA((qextent));@\\
\mbox{}\verb@        *maxNumberOfHElements=maxHElementsEncountered;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* that's it */@\\
\mbox{}\verb@        return(rowsInQ);@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* shiftRightAndRecord */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !constructQRDecomposition                                       */@\\
\mbox{}\verb@/* rwt add profiling                                               */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* -------------------------------------------------------------------------@\\
\mbox{}\verb@        QR decomposition of matrix A.  return results as q and r, plus@\\
\mbox{}\verb@        permutation vectors prow and pcol.  calls LAPACK routines dgeqp3@\\
\mbox{}\verb@        and dorqpr, which operate on dense matrices.@\\
\mbox{}\verb@@\\
\mbox{}\verb@http://www.netlib.org/lapack/lapack-3.1.1/html/dgeqp3.f.html@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@--------------------------------------------------------------------------- */@\\
\mbox{}\verb@void    dgeqp3_(int * nr,int * nc,double * denseA,@\\
\mbox{}\verb@                int * nr2,int * pcol,double * tau,@\\
\mbox{}\verb@                double * work,int *lwork,int * info);@\\
\mbox{}\verb@@\\
\mbox{}\verb@static unsigned int constructQRDecomposition (@\\
\mbox{}\verb@        unsigned int matSize, unsigned int nr, unsigned int nc,@\\
\mbox{}\verb@        double * a,unsigned  int * ja,unsigned  int * ia,@\\
\mbox{}\verb@    double * q, unsigned int * jq, unsigned int * iq,@\\
\mbox{}\verb@    double * r,unsigned  int * jr,unsigned  int * ir,@\\
\mbox{}\verb@   unsigned int * prow,unsigned int * pcol@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        int info;@\\
\mbox{}\verb@        unsigned int lwork;@\\
\mbox{}\verb@        unsigned int nzmax;@\\
\mbox{}\verb@        unsigned int i;@\\
\mbox{}\verb@        int * jpvt;@\\
\mbox{}\verb@        double * denseA;@\\
\mbox{}\verb@        double * tau;@\\
\mbox{}\verb@        double * work;@\\
\mbox{}\verb@        unsigned int rank;@\\
\mbox{}\verb@        int norm;@\\
\mbox{}\verb@        double * diag;@\\
\mbox{}\verb@        double time0 ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        denseA = (double *) calloc((unsigned)nr*nc,sizeof(double));@\\
\mbox{}\verb@        tau= (double *) calloc((unsigned)nr,sizeof(double));@\\
\mbox{}\verb@        jpvt= (int *) calloc((unsigned)nr,sizeof(int));@\\
\mbox{}\verb@        diag= (double *) calloc((unsigned)nr,sizeof(double));@\\
\mbox{}\verb@        lwork = 3*nr+1;@\\
\mbox{}\verb@        work = (double *) calloc((unsigned)lwork,sizeof(double));@\\
\mbox{}\verb@        rank=0;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        nzmax=matSize;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* convert source matrix to dense for LAPACK routines, init pivot vectors */@\\
\mbox{}\verb@        csrToDns(&nr,&nr,a,ja,ia,denseA,&nr,&info);@\\
\mbox{}\verb@        for(i=0;i<nr;i++) {pcol[i]=0;}@\\
\mbox{}\verb@        for(i=0;i<nr;i++) {prow[i]=i;}@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* dgeqp3 computes QR factorization with column pivoting of denseA */@\\
\mbox{}\verb@        /* rwt profile QR decomposition */@\\
\mbox{}\verb@        time0 = cputime() ; /* rwt */@\\
\mbox{}\verb@        dgeqp3_((int *)&nr,(int *)&nc,denseA,(int *)&nr,(int*)pcol,tau,work,(int*)&lwork,&info);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        qr_sec += cputime()-time0 ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* upper triangle of denseA has r of qr decomposition, convert to CSR */@\\
\mbox{}\verb@        dnsToCsr(&nr,&nr,&nzmax,denseA,&nr,r,jr,ir,&info);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        getUpperTriangular(&nr,r,jr,ir,r,jr,ir);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* lower triangle and tau have info for constructing q */@\\
\mbox{}\verb@        time0 = cputime() ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sparseAMAQRD(&nr,&nc,&nr,denseA,&nr,tau,work,&lwork,&info);@\\
\mbox{}\verb@        /*      printf("dorgqr returned %d \n",info);*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        qr_sec += cputime()-time0 ; /* rwt */@\\
\mbox{}\verb@        qr_count ++ ;  /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* convert q to CSR and transpose (use denseA for workspace) */@\\
\mbox{}\verb@        dnsToCsr(&nr,&nr,&nzmax,denseA,&nr,q,jq,iq,&info);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        inPlaceTranspose(&nr,&nr,q,jq,iq,denseA,&info);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        for(i=0;i<nr;i++) {pcol[i]--;}@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* find rank of r matrix */@\\
\mbox{}\verb@        norm=0;@\\
\mbox{}\verb@        normsByRow(&nr, &norm, r, jr, ir, diag);@\\
\mbox{}\verb@        rank=0;@\\
\mbox{}\verb@        for(i=0;i<nr;i++) {@\\
\mbox{}\verb@                if(diag[i]/diag[0] > ZERO_TOLERANCE)@\\
\mbox{}\verb@                        rank++;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* and we're done */@\\
\mbox{}\verb@        free(denseA);@\\
\mbox{}\verb@        free(tau);@\\
\mbox{}\verb@        free(jpvt);@\\
\mbox{}\verb@        free(diag);@\\
\mbox{}\verb@        free(work);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        return(rank);@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* constructQRDecomposition */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb14}{14}\NWlink{nuweb15}{, 15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17}{, 17}\NWlink{nuweb18}{, 18}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap3}\raggedright\small
\NWtarget{nuweb16}{} \verb@"devsparseAMA.c"@\nobreak\ {\footnotesize {16}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !annihilateRows                                                 */@\\
\mbox{}\verb@/* rwt add profiling, ztol                                         */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* ----------------------------------------------------------------------------------------@\\
\mbox{}\verb@    compute QR decomposition of rightmost block of H matrix (H-theta), then premultiply H@\\
\mbox{}\verb@    by resulting q and reorder matrix by rows so that the bottom rows of the right block are@\\
\mbox{}\verb@    zeroed out.  return result in newHmat, along with QR decomposition and pivot vectors.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        arguments@\\
\mbox{}\verb@@\\
\mbox{}\verb@                maxNumberOfHElements                                            max space used@\\
\mbox{}\verb@            returnCode                                                                  used in sparseAMAAssert@\\
\mbox{}\verb@            hrows, hcols                                                                rows and cols in H@\\
\mbox{}\verb@            hmat, hmatj, hmati,                                                 H matrix in CSR format@\\
\mbox{}\verb@            newHmat, newHmatj, newHmati,                                transformed H matrix in CSR format@\\
\mbox{}\verb@            annihilator, annihilatorj, annihilatori,    q matrix from QR decomposition of H-theta@\\
\mbox{}\verb@            rmat, rmatj, rmati,                                                 r matrix from QR decomposition of H-theta@\\
\mbox{}\verb@            prow                                                                                reordering of H matrix by rows (?)@\\
\mbox{}\verb@            pcol                                                                                column pivots from QR decomposition@\\
\mbox{}\verb@@\\
\mbox{}\verb@----------------------------------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@static unsigned int annihilateRows(@\\
\mbox{}\verb@        unsigned int *maxNumberOfHElements,@\\
\mbox{}\verb@   unsigned int *returnCode,@\\
\mbox{}\verb@   unsigned int hrows,unsigned int hcols,@\\
\mbox{}\verb@    double * hmat,unsigned int * hmatj,unsigned int * hmati,@\\
\mbox{}\verb@    double * newHmat,unsigned int * newHmatj,unsigned int * newHmati,@\\
\mbox{}\verb@    double * annihilator,unsigned int * annihilatorj,unsigned int * annihilatori,@\\
\mbox{}\verb@    double * rmat,unsigned int * rmatj,unsigned int * rmati,@\\
\mbox{}\verb@    unsigned int * prow,unsigned int * pcol@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        unsigned int i,j;static unsigned int maxHElementsEncountered=0;@\\
\mbox{}\verb@        double ztol;unsigned int rnk;unsigned int len;unsigned int * perm;@\\
\mbox{}\verb@        double * rightBlock;unsigned int * rightBlockj;unsigned int * rightBlocki;@\\
\mbox{}\verb@        double * tempHmat;unsigned int * tempHmatj;unsigned int * tempHmati;@\\
\mbox{}\verb@        unsigned int job,i1,i2,j1,j2,resRows,resColumns,ierr,nzmax;@\\
\mbox{}\verb@        int * iw;@\\
\mbox{}\verb@        double time0 ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* allocate space */@\\
\mbox{}\verb@        perm            = (unsigned int *) calloc((unsigned)hrows,sizeof(unsigned int));@\\
\mbox{}\verb@        rightBlock      = (double *) calloc(RBLOCKSIZE,sizeof(double));@\\
\mbox{}\verb@        rightBlockj     = (unsigned int *) calloc(RBLOCKSIZE,sizeof(unsigned int));@\\
\mbox{}\verb@        rightBlocki = (unsigned int *) calloc((unsigned)hrows+1,sizeof(unsigned int));@\\
\mbox{}\verb@        tempHmat        = (double *) calloc(HMATSIZE,sizeof(double));@\\
\mbox{}\verb@        tempHmatj       = (unsigned int *) calloc(HMATSIZE,sizeof(unsigned int));@\\
\mbox{}\verb@        tempHmati       = (unsigned int *) calloc((unsigned)hrows+1,sizeof(unsigned int));@\\
\mbox{}\verb@        iw                      = (int *) calloc((unsigned)HMATSIZE,sizeof(int));@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* copy rightmost block of H to rightBlock */@\\
\mbox{}\verb@        job=1; i1=1; i2=hrows;@\\
\mbox{}\verb@        ztol=ZERO_TOLERANCE ;@\\
\mbox{}\verb@        j1=hcols-hrows+1; j2=hcols;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        extractSubmatrix (@\\
\mbox{}\verb@                &hrows, &job, &i1, &i2, &j1, &j2, hmat, hmatj, hmati,@\\
\mbox{}\verb@                &resRows, &resColumns, rightBlock, rightBlockj, rightBlocki@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* QR decomposition of rightmost block of H.  results returned in annihilator (q),@\\
\mbox{}\verb@        rmat (r), and prow and pcol  */@\\
\mbox{}\verb@        time0 = cputime() ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        rnk=constructQRDecomposition(@\\
\mbox{}\verb@                (unsigned int)RBLOCKSIZE, hrows, hrows, rightBlock, rightBlockj, rightBlocki,@\\
\mbox{}\verb@                annihilator, annihilatorj, annihilatori,@\\
\mbox{}\verb@                rmat, rmatj, rmati,@\\
\mbox{}\verb@                prow, pcol@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        time_constructQRDecomposition += cputime() - time0 ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* zero means zero ... */@\\
\mbox{}\verb@        ztol=ZERO_TOLERANCE; job=1; len=HMATSIZE; ierr=0;@\\
\mbox{}\verb@/*@\\
\mbox{}\verb@        dropSmallElements (@\\
\mbox{}\verb@                &hrows, &job, &ztol, &len,@\\
\mbox{}\verb@                annihilator, annihilatorj, annihilatori,@\\
\mbox{}\verb@                annihilator, annihilatorj, annihilatori, &ierr@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* calculate ordering of new H by rows depending on rank (?).  nb first row number zero not one */@\\
\mbox{}\verb@        for(i=0;i<hrows;i++) {@\\
\mbox{}\verb@                if(i>=rnk) {@\\
\mbox{}\verb@                        perm[prow[i]]=i-rnk+1;@\\
\mbox{}\verb@                } else {@\\
\mbox{}\verb@                        perm[prow[i]]=i+hrows-rnk+1;@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* premultiply H by q from QR decomposition to create zero rows, results in newHmat */@\\
\mbox{}\verb@        time0 = cputime() ; /* rwt */@\\
\mbox{}\verb@        nzmax=HMATSIZE;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sparseMult (@\\
\mbox{}\verb@                &hrows, &hcols, &nzmax, iw, &job,@\\
\mbox{}\verb@                annihilator, annihilatorj, annihilatori,@\\
\mbox{}\verb@                hmat, hmatj, hmati,@\\
\mbox{}\verb@                newHmat, newHmatj, newHmati, &ierr@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        time_sparseMult += cputime()-time0 ; /* rwt */@\\
\mbox{}\verb@        sparseAMAAssert(ierr==0, nzmaxTooSmallAnnihilateRows);@\\
\mbox{}\verb@        if (*returnCode) return (BADRC) ;@\\
\mbox{}\verb@        bumpSparseAMA((newHmati[hrows]-newHmati[0]));@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* reorder rows of new Hmat using permutation calculated above, store in tempHmat */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        permuteRows(&hrows,newHmat,newHmatj,newHmati,tempHmat,tempHmatj,tempHmati,perm,&job);@\\
\mbox{}\verb@        bumpSparseAMA((tempHmati[hrows]-tempHmati[0]));@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* zero out numerically small elements in right block of tempHmat */@\\
\mbox{}\verb@        for(i=0;i<hrows-rnk;i++) {@\\
\mbox{}\verb@                for(j=tempHmati[i];j<tempHmati[i+1];j++) {@\\
\mbox{}\verb@                        if(((tempHmatj[j-1]>hcols-hrows)))@\\
\mbox{}\verb@                                tempHmat[j-1]=0.0;@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* and save new H matrix for next time */@\\
\mbox{}\verb@        len=HMATSIZE;@\\
\mbox{}\verb@        dropSmallElements(&hrows,&job,&ztol,&len,tempHmat,tempHmatj,tempHmati,newHmat,newHmatj,newHmati,&ierr);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        free(perm);@\\
\mbox{}\verb@        free(iw);@\\
\mbox{}\verb@        free(tempHmat);@\\
\mbox{}\verb@        free(tempHmatj);@\\
\mbox{}\verb@        free(tempHmati);@\\
\mbox{}\verb@        free(rightBlock);@\\
\mbox{}\verb@        free(rightBlockj);@\\
\mbox{}\verb@        free(rightBlocki);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sparseAMAAssert(validCSRMatrix(hrows,hmat,hmatj,hmati), annihilateRowsPostValidH);@\\
\mbox{}\verb@        if (*returnCode) return (BADRC) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        *maxNumberOfHElements=maxHElementsEncountered;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        return(rnk);@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* annihilateRows */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !autoRegression                                                 */@\\
\mbox{}\verb@/* rwt allocate space for rightMostAllZeroQ                        */@\\
\mbox{}\verb@/* rwt add profiling                                               */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* -------------------------------------------------------------------------@\\
\mbox{}\verb@@\\
\mbox{}\verb@        First stage of computation of unconstrained autoregression X(t) = A X(t-1).@\\
\mbox{}\verb@        Transforms matrix of structural coefficients (H) so that right-most block@\\
\mbox{}\verb@        (H-theta) is non-singular.  This is done by shifting zero rows of H-theta@\\
\mbox{}\verb@        right and storing them in Q as auxiliary initial conditions.  A QR decomposition@\\
\mbox{}\verb@        is performed on H-theta, which is premultiplied by the q matrix to generate@\\
\mbox{}\verb@        additional zero rows, which are then shifted as well.  This process continues@\\
\mbox{}\verb@        until H-theta becomes non-singular.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        Arguments@\\
\mbox{}\verb@@\\
\mbox{}\verb@                *maxNumberOfHElements                   on input, number of elements to allocate for hmat storage@\\
\mbox{}\verb@                returnCode                                              on output, number of elements to allocate for qmat storage@\\
\mbox{}\verb@@\\
\mbox{}\verb@                hrows, hcols                                    rows and columns in H matrix@\\
\mbox{}\verb@                hmat, hmatj, hmati                              structural coefficients matrix in CSR format@\\
\mbox{}\verb@                qmat, qmatj, qmati                              asymptotic constraint matrix in CSR format.@\\
\mbox{}\verb@@\\
\mbox{}\verb@                newHmat, newHmatj, newHmati     transformed structural coefficients matrix in CSR format@\\
\mbox{}\verb@                annihilator, annihilatorj,              q matrix from final QR decomposition of H-theta@\\
\mbox{}\verb@                        annihilatori@\\
\mbox{}\verb@                rmat, rmatj,  rmati                             r matrix from final QR decomposition of H-theta@\\
\mbox{}\verb@                prow (output)                                   permution of rows in H-theta (?)@\\
\mbox{}\verb@                pcol (output)                                   column pivots from final QR decomposition of H-theta@\\
\mbox{}\verb@                aPointToVoid                                    not used@\\
\mbox{}\verb@@\\
\mbox{}\verb@------------------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@static unsigned int autoRegression(@\\
\mbox{}\verb@        unsigned int *maxNumberOfHElements,@\\
\mbox{}\verb@    unsigned int *returnCode,@\\
\mbox{}\verb@    unsigned int hrows,unsigned int hcols,@\\
\mbox{}\verb@    double * hmat,unsigned int * hmatj,unsigned int * hmati,@\\
\mbox{}\verb@    double * qmat,unsigned int * qmatj,unsigned int * qmati,@\\
\mbox{}\verb@    double * newHmat,unsigned int * newHmatj,unsigned int * newHmati,@\\
\mbox{}\verb@    double * annihilator,unsigned int * annihilatorj,unsigned int * annihilatori,@\\
\mbox{}\verb@    double * rmat,unsigned int * rmatj,unsigned int * rmati,@\\
\mbox{}\verb@    unsigned int * prow,unsigned int * pcol@\\
\mbox{}\verb@@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        double time0, time_annihilateRows, time_shiftRightAndRecord ; /* rwt */@\\
\mbox{}\verb@        unsigned int count_ARloop ; /* rwt */@\\
\mbox{}\verb@        unsigned int aOne;unsigned int swapped;unsigned int i;static unsigned int maxHElementsEncountered=0;@\\
\mbox{}\verb@        unsigned int len;unsigned int ierr;double ztol;unsigned int job;@\\
\mbox{}\verb@        unsigned int rowsInQ,rnk;@\\
\mbox{}\verb@        unsigned int * tmpHmati;unsigned int * tmpHmatj;@\\
\mbox{}\verb@        double * tmpHmat;@\\
\mbox{}\verb@        unsigned int * chkJs;@\\
\mbox{}\verb@        unsigned int valid;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* save original maxspace parameter */@\\
\mbox{}\verb@        unsigned int originalMaxHElements;@\\
\mbox{}\verb@        @\\
\mbox{}\verb@@\\
\mbox{}\verb@originalMaxHElements=*maxNumberOfHElements;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        time_shiftRightAndRecord = 0 ;  /* rwt */@\\
\mbox{}\verb@        time_annihilateRows = 0 ;               /* rwt */@\\
\mbox{}\verb@        count_ARloop = 0 ;                              /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* init ... */@\\
\mbox{}\verb@        aOne=1;swapped=0;rowsInQ=0;rnk=0;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* initialize permuatation vectors */@\\
\mbox{}\verb@        for (i=0;i<hrows;i++)@\\
\mbox{}\verb@                prow[i]=i;@\\
\mbox{}\verb@        for (i=0;i<hrows;i++)@\\
\mbox{}\verb@            pcol[i]=i;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* rwt init profile vars */@\\
\mbox{}\verb@        time_rightMostAllZeroQ = 0 ;            /* accumulated in rightMostAllZeroQ */@\\
\mbox{}\verb@        count_rightMostAllZeroQ = 0 ;           /* accumulated in rightMostAllZeroQ */@\\
\mbox{}\verb@        time_rmazq_alloc = 0 ;                          /* accumulated in rightMostAllZeroQ */@\\
\mbox{}\verb@        time_constructQRDecomposition = 0;      /* accumulated in annihilateRows */@\\
\mbox{}\verb@        time_sparseMult = 0 ;                           /* accumulated in annihilateRows */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* while rightmost block of H is singular ... */@\\
\mbox{}\verb@        while (rnk != hrows) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                count_ARloop ++ ;  /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* clean up near-zeros */@\\
\mbox{}\verb@                ztol=ZERO_TOLERANCE;ztol=1.0e-8;job=3;len=HMATSIZE;ierr=0;@\\
\mbox{}\verb@                dropSmallElements(&hrows,&job,&ztol,&len,hmat,hmatj,hmati,hmat,hmatj,hmati,&ierr);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* shift zero rows of rightmost block of H to the right and copy into Q as auxiliary initial conditions */@\\
\mbox{}\verb@                time0 = cputime() ; /* rwt */@\\
\mbox{}\verb@                rowsInQ=shiftRightAndRecord(maxNumberOfHElements,returnCode,hrows,rowsInQ,@\\
\mbox{}\verb@                        qmat,qmatj,qmati,hrows,hcols,hmat,hmatj,hmati@\\
\mbox{}\verb@                );@\\
\mbox{}\verb@@\\
\mbox{}\verb@                if (*returnCode) return 0u ;@\\
\mbox{}\verb@                time_shiftRightAndRecord += cputime() - time0 ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* record space used and reset */@\\
\mbox{}\verb@                bumpSparseAMA(*maxNumberOfHElements);@\\
\mbox{}\verb@                *maxNumberOfHElements=originalMaxHElements;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* Perform QR decomposition on rightmost block of H, and premultiply H by left singular vectors.@\\
\mbox{}\verb@                (This creates additional zero rows if H-theta is singular.  Recompute rank of H-theta */@\\
\mbox{}\verb@                time0 = cputime() ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@                rnk=annihilateRows(maxNumberOfHElements,returnCode,hrows,hcols,@\\
\mbox{}\verb@                        hmat, hmatj, hmati,@\\
\mbox{}\verb@                        newHmat, newHmatj, newHmati,@\\
\mbox{}\verb@                        annihilator, annihilatorj, annihilatori,@\\
\mbox{}\verb@                        rmat, rmatj, rmati,@\\
\mbox{}\verb@                        prow, pcol@\\
\mbox{}\verb@                );@\\
\mbox{}\verb@@\\
\mbox{}\verb@                if (*returnCode) return 0u ;@\\
\mbox{}\verb@                time_annihilateRows += cputime()-time0 ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* record space used and reset */@\\
\mbox{}\verb@                bumpSparseAMA(*maxNumberOfHElements);@\\
\mbox{}\verb@                *maxNumberOfHElements=originalMaxHElements;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* if still not full rank, set up to go again */@\\
\mbox{}\verb@                if (rnk != hrows) {@\\
\mbox{}\verb@                        tmpHmat=hmat; tmpHmati=hmati; tmpHmatj=hmatj;@\\
\mbox{}\verb@                        hmat=newHmat; hmati=newHmati; hmatj=newHmatj;@\\
\mbox{}\verb@                        newHmat=tmpHmat; newHmati=tmpHmati; newHmatj=tmpHmatj;@\\
\mbox{}\verb@                        if (swapped) {swapped=0;} else {swapped=1;}@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        if(swapped) {@\\
\mbox{}\verb@                copyMatrix(&hrows,&aOne,hmat,hmatj,hmati,&aOne,newHmat,newHmatj,newHmati);@\\
\mbox{}\verb@                bumpSparseAMA((newHmati[hrows]-newHmati[0]));@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sparseAMAAssert(validCSRMatrix(rowsInQ,qmat,qmatj,qmati), autoRegressionPostValidQ);@\\
\mbox{}\verb@        sparseAMAAssert(validCSRMatrix(hrows,newHmat,newHmatj,newHmati), autoRegressionPostValidH);@\\
\mbox{}\verb@        sparseAMAAssert(validCSRMatrix(hrows,annihilator,annihilatorj,annihilatori), autoRegressionPostValidAnnihilator);@\\
\mbox{}\verb@        sparseAMAAssert(validCSRMatrix(hrows,rmat,rmatj,rmati), autoRegressionPostValidR);@\\
\mbox{}\verb@        if (*returnCode) return 0u ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /*      The Js vector makes the correspondence between the columns of the */@\\
\mbox{}\verb@        /*      reduced dimension matrix and the original input matrix.           */@\\
\mbox{}\verb@        /*      The Js vector should contain 0's for excluded columns and         */@\\
\mbox{}\verb@        /*  each integer from 1 to *essential for retained columns.           */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        chkJs=(unsigned int *)calloc((unsigned)hrows,sizeof(unsigned int));@\\
\mbox{}\verb@        for(i=0;i<hrows;i++) chkJs[i]=0;@\\
\mbox{}\verb@        for(i=0;i<hrows;i++) if(prow[i]>=0&&prow[i]<hrows) chkJs[prow[i]]+=1;@\\
\mbox{}\verb@        for(i=0;i<hrows;i++) chkJs[i]=0;@\\
\mbox{}\verb@        for(i=0;i<hrows;i++) if(pcol[i]>=0&&pcol[i]<hrows) chkJs[pcol[i]]+=1;@\\
\mbox{}\verb@        valid=TRUE;@\\
\mbox{}\verb@        for(i=0;i<hrows;i++) if(chkJs[i]!=1) valid=FALSE;@\\
\mbox{}\verb@        free(chkJs);@\\
\mbox{}\verb@        sparseAMAAssert(valid, autoRegressionPostValidJs);@\\
\mbox{}\verb@        if (*returnCode) return 0u ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* all done ... */@\\
\mbox{}\verb@        *maxNumberOfHElements=maxHElementsEncountered;@\\
\mbox{}\verb@        return(rowsInQ);@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* autoRegression */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !identifyEssential                                              */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* ------------------------------------------------------------------@\\
\mbox{}\verb@        compute dimension of transition matrix.  Loosely speaking, that's@\\
\mbox{}\verb@        the number of nonzero columns in H ...@\\
\mbox{}\verb@@\\
\mbox{}\verb@        arguments@\\
\mbox{}\verb@@\\
\mbox{}\verb@                neq                                             number of rows in H matrix@\\
\mbox{}\verb@                hcols                                   number of cols in H@\\
\mbox{}\verb@                hmat, hmatj, hmati              H matrix in CSR format@\\
\mbox{}\verb@                js                                              vector masking nonzero columns in H@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@------------------------------------------------------------------ */@\\
\mbox{}\verb@static unsigned int identifyEssential(@\\
\mbox{}\verb@        unsigned int neq,@\\
\mbox{}\verb@        unsigned int hcols,@\\
\mbox{}\verb@    double *hmat, unsigned int *hmatj, unsigned int *hmati,@\\
\mbox{}\verb@    unsigned int * js@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        unsigned int i, j, ia, norm;@\\
\mbox{}\verb@        double * diag, epsi;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* write column norms of H (max abs values) into 'diag'  */@\\
\mbox{}\verb@        diag=(double *)calloc((unsigned)hcols,sizeof(double));@\\
\mbox{}\verb@        norm=0;@\\
\mbox{}\verb@        cnrms_(&neq, &norm, hmat, hmatj, hmati, diag) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* set js to indicate nonzero columns */@\\
\mbox{}\verb@        epsi=ZERO_TOLERANCE;@\\
\mbox{}\verb@        for (i = 0; i < hcols-neq; ++i)@\\
\mbox{}\verb@        if (diag[i]>epsi)@\\
\mbox{}\verb@                for (j=i; j<hcols-neq; j=j+neq)@\\
\mbox{}\verb@                js[j] = 1;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* dimension is the number of nonzeros in js */@\\
\mbox{}\verb@        ia = 0;@\\
\mbox{}\verb@        for (i=0; i<hcols-neq; ++i)@\\
\mbox{}\verb@        if (js[i]>0)@\\
\mbox{}\verb@                js[i] = ++ia;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        free(diag);@\\
\mbox{}\verb@        return(ia);@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* identifyEssential */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !constructA                                                     */@\\
\mbox{}\verb@/* rwt add profiling                                               */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* ------------------------------------------------------------------@\\
\mbox{}\verb@        construct A == [ 0   I ]@\\
\mbox{}\verb@                       [ gamma ]@\\
\mbox{}\verb@@\\
\mbox{}\verb@    where gamma == [ H-theta inverse * H ]@\\
\mbox{}\verb@@\\
\mbox{}\verb@        use QR decomposition from autoRegression above to avoid inverting@\\
\mbox{}\verb@        H-theta.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        arguments@\\
\mbox{}\verb@@\\
\mbox{}\verb@                maxNumberOfHElements                    max size parameter@\\
\mbox{}\verb@                returnCode                                              ptr to global return code@\\
\mbox{}\verb@                hrows, hcols                                    rows, columns in H matrix@\\
\mbox{}\verb@                ia                                                              ?@\\
\mbox{}\verb@                js                                                              pointers to nonzero cols in gamma@\\
\mbox{}\verb@                hmat, hmatj, hmati                              H matrix in CSR format@\\
\mbox{}\verb@                qmat, qmatj, qmati                              Q matrix in CSR format@\\
\mbox{}\verb@                rmat, rmatj, rmati                              r matrix from QR decomposition of H-theta@\\
\mbox{}\verb@                prow, pcol                                              row and column permutations of H-theta (?)@\\
\mbox{}\verb@                damat                                                   dense version of A ??? used in call to dgeesx@\\
\mbox{}\verb@@\\
\mbox{}\verb@------------------------------------------------------------------- */@\\
\mbox{}\verb@static void constructA (@\\
\mbox{}\verb@        unsigned int *maxNumberOfHElements,@\\
\mbox{}\verb@        unsigned int *returnCode,@\\
\mbox{}\verb@        unsigned int hrows,unsigned int hcols,unsigned int ia,unsigned int * js,@\\
\mbox{}\verb@        double * hmat,unsigned int * hmatj,unsigned int * hmati,@\\
\mbox{}\verb@        double * qmat,unsigned int * qmatj,unsigned int * qmati,@\\
\mbox{}\verb@        double * rmat,unsigned int * rmatj,unsigned int * rmati,@\\
\mbox{}\verb@        unsigned int * prow,unsigned int * pcol,@\\
\mbox{}\verb@        double * damat@\\
\mbox{}\verb@@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        double ztol;static unsigned int maxHElementsEncountered=0;@\\
\mbox{}\verb@        double val;@\\
\mbox{}\verb@        unsigned int nzmax;@\\
\mbox{}\verb@        unsigned int ierr;unsigned int * iw;@\\
\mbox{}\verb@        unsigned int i;unsigned int job;unsigned int j;@\\
\mbox{}\verb@        unsigned int * perm;unsigned int rowNow;@\\
\mbox{}\verb@        unsigned int len;unsigned int ioff;unsigned int nr;unsigned int nc;unsigned int aOne;unsigned int ndns;unsigned int i1,i2,j1,j2;@\\
\mbox{}\verb@        unsigned int * idiag;double * diag;@\\
\mbox{}\verb@        double * xo;unsigned int * ixo;unsigned int * jxo;double * x;double * y;@\\
\mbox{}\verb@        double * gmat;unsigned int * gmatj;unsigned int * gmati;@\\
\mbox{}\verb@        double * tempHmat;unsigned int * tempHmatj;unsigned int * tempHmati;@\\
\mbox{}\verb@        double * tempRmat;unsigned int * tempRmatj;unsigned int * tempRmati;@\\
\mbox{}\verb@        double time0 ;@\\
\mbox{}\verb@        /*      static unsigned int originalMaxHElements;@\\
\mbox{}\verb@                originalMaxHElements=*maxNumberOfHElements;*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* allocate space */@\\
\mbox{}\verb@        perm=(unsigned int *)calloc((unsigned)hrows,sizeof(unsigned int));@\\
\mbox{}\verb@        iw =(unsigned int *)calloc((unsigned)hcols,sizeof(unsigned int));@\\
\mbox{}\verb@        xo=(double *)calloc((unsigned)hrows,sizeof(double));@\\
\mbox{}\verb@        ixo=(unsigned int *)calloc((unsigned)hrows+1,sizeof(unsigned int));@\\
\mbox{}\verb@        jxo=(unsigned int *)calloc((unsigned)hrows,sizeof(unsigned int));@\\
\mbox{}\verb@        x=(double *)calloc((unsigned)hrows * ia,sizeof(double));@\\
\mbox{}\verb@        y=(double *)calloc((unsigned)hrows * ia,sizeof(double));@\\
\mbox{}\verb@        tempHmat=(double *)calloc(HMATSIZE,sizeof(double));@\\
\mbox{}\verb@        tempHmatj=(unsigned int *)calloc(HMATSIZE,sizeof(unsigned int));@\\
\mbox{}\verb@        tempHmati=(unsigned int *)calloc((unsigned)hrows+1,sizeof(unsigned int));@\\
\mbox{}\verb@        tempRmat=(double *)calloc(RBLOCKSIZE,sizeof(double));@\\
\mbox{}\verb@        tempRmatj=(unsigned int *)calloc(RBLOCKSIZE,sizeof(unsigned int));@\\
\mbox{}\verb@        tempRmati=(unsigned int *)calloc((unsigned)hrows+1,sizeof(unsigned int));@\\
\mbox{}\verb@        gmat=(double *)calloc(HMATSIZE,sizeof(double));@\\
\mbox{}\verb@        gmatj=(unsigned int *)calloc(HMATSIZE,sizeof(unsigned int));@\\
\mbox{}\verb@        gmati=(unsigned int *)calloc((unsigned)hrows+1,sizeof(unsigned int));@\\
\mbox{}\verb@        diag=(double *)calloc((unsigned)hrows,sizeof(double));@\\
\mbox{}\verb@        idiag=(unsigned int *)calloc((unsigned)hrows,sizeof(unsigned int));@\\
\mbox{}\verb@@\\
\mbox{}\verb@        *returnCode=0;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* construct sparse representation of squeezed a matrix */@\\
\mbox{}\verb@        /* first for rows above gamma */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* multiply Q by H, store in tempHmat.  (is this gamma?) */@\\
\mbox{}\verb@        job=1;@\\
\mbox{}\verb@        nzmax=HMATSIZE;@\\
\mbox{}\verb@        time0 = cputime() ;@\\
\mbox{}\verb@        time_sparseMult = 0 ;@\\
\mbox{}\verb@        sparseMult (&hrows, &hcols, &nzmax, iw, &job, qmat, qmatj, qmati,@\\
\mbox{}\verb@                hmat, hmatj, hmati, tempHmat, tempHmatj, tempHmati, &ierr@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        time_sparseMult += cputime()-time0 ;@\\
\mbox{}\verb@        sparseAMAAssert(ierr == 0, nzmaxTooSmallConstructA);@\\
\mbox{}\verb@        if (*returnCode) return ;@\\
\mbox{}\verb@        bumpSparseAMA((tempHmati[hrows]-tempHmati[0]));@\\
\mbox{}\verb@        ztol=ZERO_TOLERANCE;len=HMATSIZE;@\\
\mbox{}\verb@        dropSmallElements(&hrows,&job,&ztol,&len,tempHmat,tempHmatj,tempHmati,tempHmat,tempHmatj,tempHmati,&ierr);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* permute rows of r (from QR decomposition of H) and H to form gmat=gamma? */@\\
\mbox{}\verb@        /* first row number zero not one*/@\\
\mbox{}\verb@        for(i=0;i<hrows;i++)@\\
\mbox{}\verb@                perm[prow[i]]=i+1;@\\
\mbox{}\verb@        permuteRows(&hrows,rmat,rmatj,rmati,tempRmat,tempRmatj,tempRmati,perm,&job);@\\
\mbox{}\verb@        permuteRows(&hrows,tempHmat,tempHmatj,tempHmati,gmat,gmatj,gmati,perm,&job);@\\
\mbox{}\verb@        for(i=0;i<hrows;i++)@\\
\mbox{}\verb@                perm[pcol[i]]=i+1;@\\
\mbox{}\verb@        /* this line commented out on purpose ... */@\\
\mbox{}\verb@        /*permuteCols(&hrows,tempRmat,tempRmatj,tempRmati,tempRmat,tempRmatj,tempRmati,perm,&job);*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* diagonal elements of permuted r matrix */@\\
\mbox{}\verb@        job=0;@\\
\mbox{}\verb@        ioff=0;@\\
\mbox{}\verb@        getDiagonalElements (&hrows, &hcols, &job, tempRmat, tempRmatj, tempRmati, &len, diag, idiag, &ioff) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* invert diagonal elements and multiply by R and gmat to make the unit upper triangular for usol_ */@\\
\mbox{}\verb@        for(i=0;i<hrows;i++)diag[i]=1/diag[i];@\\
\mbox{}\verb@        job=0;@\\
\mbox{}\verb@        diagMatTimesSparseMat (&hrows, &job, diag, tempRmat, tempRmatj, tempRmati, tempRmat, tempRmatj, tempRmati);@\\
\mbox{}\verb@        diagMatTimesSparseMat (&hrows, &job, diag, gmat, gmatj, gmati, gmat, gmatj, gmati);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* extract nonzero columns of gmat for backsolving to get components of gamma */@\\
\mbox{}\verb@        job=1;@\\
\mbox{}\verb@        i1=1; i2=hrows; aOne=1; ndns=hrows; rowNow=0;@\\
\mbox{}\verb@        time_extract = 0 ;              /* rwt */@\\
\mbox{}\verb@        time_backsolve = 0 ;    /* rwt */@\\
\mbox{}\verb@        count_constructA = 0 ;  /* rwt */@\\
\mbox{}\verb@        for(i=0; i<hcols-hrows; i++) {@\\
\mbox{}\verb@                if(js[i]) {@\\
\mbox{}\verb@                        j1=j2=i+1;@\\
\mbox{}\verb@                        count_constructA ++ ; /* rwt */@\\
\mbox{}\verb@                        time0 = cputime() ; /* rwt */@\\
\mbox{}\verb@                        extractSubmatrix(&hrows,&job,&i1,&i2,&j1,&j2,gmat,gmatj,gmati,&nr,&nc,xo,jxo,ixo);@\\
\mbox{}\verb@                        time_extract += cputime()-time0 ; /* rwt */@\\
\mbox{}\verb@                        csrToDns(&hrows,&aOne,xo,jxo,ixo,y+(rowNow*hrows),&ndns,&ierr);@\\
\mbox{}\verb@                        sparseAMAAssert(ierr == 0, ndnsTooSmall);@\\
\mbox{}\verb@                        if (*returnCode) return ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        time0 = cputime() ;@\\
\mbox{}\verb@                        backSolveUnitUpperTriangular (&hrows, tempRmat, tempRmatj, tempRmati,@\\
\mbox{}\verb@                                x+(rowNow*hrows), y+(rowNow*hrows)@\\
\mbox{}\verb@                        );@\\
\mbox{}\verb@                        time_backsolve += cputime() - time0 ;@\\
\mbox{}\verb@                        rowNow++;@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* finally, build A matrix.  Build in dense form, needed by dgeesx */@\\
\mbox{}\verb@        for(i=0;i<ia*ia;i++)@\\
\mbox{}\verb@                *(damat+i)=0.0;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        for(i=0;i<hcols-2*hrows;i++) {@\\
\mbox{}\verb@                if(js[i]) {@\\
\mbox{}\verb@                *(damat+((js[i+hrows]-1))+(js[i]-1)*ia)=1;@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        for(i=hcols-2*hrows;i<hcols-hrows;i++) {@\\
\mbox{}\verb@                if(js[i]) {@\\
\mbox{}\verb@                        for(j=0;j<hcols-hrows;j++) {@\\
\mbox{}\verb@                                if(js[j] ) {@\\
\mbox{}\verb@                                        val= -1* *(x+(js[j]-1)*hrows+perm[i-(hcols-2*hrows)]-1);@\\
\mbox{}\verb@                                        if (fabs(val) > ZERO_TOLERANCE) {@\\
\mbox{}\verb@                                        *(damat+((js[i]-1)*ia)+js[j]-1)=val;@\\
\mbox{}\verb@                                        }@\\
\mbox{}\verb@                                }@\\
\mbox{}\verb@                        }@\\
\mbox{}\verb@            }@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* all done */@\\
\mbox{}\verb@        free(x);@\\
\mbox{}\verb@        free(y);@\\
\mbox{}\verb@        free(xo);@\\
\mbox{}\verb@        free(ixo);@\\
\mbox{}\verb@        free(jxo);@\\
\mbox{}\verb@        free(diag);@\\
\mbox{}\verb@        free(idiag);@\\
\mbox{}\verb@        free(iw);@\\
\mbox{}\verb@        free(perm);@\\
\mbox{}\verb@        free(tempHmat);@\\
\mbox{}\verb@        free(tempHmatj);@\\
\mbox{}\verb@        free(tempHmati);@\\
\mbox{}\verb@        free(tempRmat);@\\
\mbox{}\verb@        free(tempRmatj);@\\
\mbox{}\verb@        free(tempRmati);@\\
\mbox{}\verb@        free(gmat);@\\
\mbox{}\verb@        free(gmatj);@\\
\mbox{}\verb@        free(gmati);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        *maxNumberOfHElements=maxHElementsEncountered;@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* constructA */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb14}{14}\NWlink{nuweb15}{, 15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17}{, 17}\NWlink{nuweb18}{, 18}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap4}\raggedright\small
\NWtarget{nuweb17}{} \verb@"devsparseAMA.c"@\nobreak\ {\footnotesize {17}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !useArpack                                                      */@\\
\mbox{}\verb@/* rwt add profiling                                               */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* ------------------------------------------------------------------@\\
\mbox{}\verb@        wrapper function to call arpack routines to compute eigenvectors@\\
\mbox{}\verb@        and eigen values for matrix A.  returns arpack error code.@\\
\mbox{}\verb@        computes number of large roots if global TESTBLANCHARDKAHN=true@\\
\mbox{}\verb@@\\
\mbox{}\verb@        arguments@\\
\mbox{}\verb@@\\
\mbox{}\verb@                maxNumberOfHElements                            max size parameter@\\
\mbox{}\verb@                maxnev                                                          number of eigenvalues to calculate@\\
\mbox{}\verb@                nroot                                                           dimension of eigenproblem@\\
\mbox{}\verb@                amat, amatj, amati                                      A matrix in CSR format@\\
\mbox{}\verb@                spanVecs                                                        array of eigenvectors@\\
\mbox{}\verb@                rootr, rooti                                            vectors of real and imaginary roots@\\
\mbox{}\verb@                &nlarge                                                         ptr to number of large roots@\\
\mbox{}\verb@------------------------------------------------------------------------- */@\\
\mbox{}\verb@static unsigned int useArpack(@\\
\mbox{}\verb@        unsigned int *maxNumberOfHElements, unsigned int maxnev, unsigned int nroot,@\\
\mbox{}\verb@        double * amat,unsigned int * amatj,unsigned int * amati,@\\
\mbox{}\verb@        double * spanVecs,double * rootr,double * rooti,@\\
\mbox{}\verb@        unsigned int *nlarge@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        unsigned int ishfts=1;@\\
\mbox{}\verb@        unsigned int maxitr=300;@\\
\mbox{}\verb@        unsigned int model=1;@\\
\mbox{}\verb@        unsigned int ido;unsigned int lworkl;unsigned int info;@\\
\mbox{}\verb@        unsigned int rvec=1;@\\
\mbox{}\verb@        double tol=0;@\\
\mbox{}\verb@        char  bmat[1]={'I'};@\\
\mbox{}\verb@        char  huhmat[1]={'A'};@\\
\mbox{}\verb@        char  which[2]={'L','M'};@\\
\mbox{}\verb@        unsigned int * iparam;unsigned int * ipntr;unsigned int * select;@\\
\mbox{}\verb@        double * workd;double sigmar;double sigmai;@\\
\mbox{}\verb@        double * ax;double * d;double * v; double * workev;double * workl;@\\
\mbox{}\verb@        double * resid;unsigned int maxn;unsigned int ldv;unsigned int maxncv;@\\
\mbox{}\verb@        double time0 ;@\\
\mbox{}\verb@        unsigned int i, lowpos;@\\
\mbox{}\verb@        double thisroot, lowroot, realpart, imagpart ;@\\
\mbox{}\verb@/*      unsigned unsigned int ONE=1,WO=2*/@\\
\mbox{}\verb@        unsigned int original_maxnev ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        time_arpack = 0.0 ;                             /* declared in sparseAMA() */@\\
\mbox{}\verb@        time_sparseMatTimesVec = 0.0 ;  /* declared in sparseAMA() */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        ldv=maxn=nroot;@\\
\mbox{}\verb@        ido=0;info=0;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* bump maxnev so we get one extra root to check B-K conditions */@\\
\mbox{}\verb@        original_maxnev = maxnev ;@\\
\mbox{}\verb@        if (TESTBLANCHARDKAHN) {@\\
\mbox{}\verb@                maxnev += 1 ;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* number of columns in spanvecs, or something */@\\
\mbox{}\verb@        if(2* maxnev+1<maxn) {@\\
\mbox{}\verb@                maxncv=2*maxnev+1;@\\
\mbox{}\verb@        } else {@\\
\mbox{}\verb@                maxncv=maxn-1;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* allocate space for dnaupd */@\\
\mbox{}\verb@        lworkl = 3*maxncv*maxncv+6*maxncv;@\\
\mbox{}\verb@        iparam=(unsigned int *)calloc((unsigned)11,sizeof(int));@\\
\mbox{}\verb@        ipntr=(unsigned int *)calloc((unsigned)14,sizeof(int));@\\
\mbox{}\verb@        select=(unsigned int *)calloc((unsigned)maxncv,sizeof(int));@\\
\mbox{}\verb@        ax=(double *)calloc((unsigned)maxn,sizeof(double));@\\
\mbox{}\verb@        d=(double *)calloc((unsigned)maxncv*3,sizeof(double));@\\
\mbox{}\verb@        resid=(double *)calloc((unsigned)maxn,sizeof(double));@\\
\mbox{}\verb@        v=(double *)calloc((unsigned)ldv*maxncv,sizeof(double));@\\
\mbox{}\verb@        workev=(double *)calloc((unsigned)3*maxncv,sizeof(double));@\\
\mbox{}\verb@        workl=(double *)calloc((unsigned)lworkl,sizeof(double));@\\
\mbox{}\verb@        workd=(double *)calloc((unsigned)3*maxn,sizeof(double));@\\
\mbox{}\verb@@\\
\mbox{}\verb@        ishfts=1;@\\
\mbox{}\verb@        maxitr=3000;@\\
\mbox{}\verb@        model=1;@\\
\mbox{}\verb@        iparam[0]=ishfts;iparam[2]=maxitr;iparam[6]=model;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* initialize dnaupd */@\\
\mbox{}\verb@        tol=ZERO_TOLERANCE;@\\
\mbox{}\verb@                tol=1.0e-17;@\\
\mbox{}\verb@                /*      fflush (stdout);*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        time0 = cputime() ;@\\
\mbox{}\verb@/* Fortran calls in Win32 require hidden args for string length */@\\
\mbox{}\verb@/* strings are char arrays, so don't take addresses when calling */@\\
\mbox{}\verb@/* #ifdef WIN32@\\
\mbox{}\verb@        dnaupd_( &ido, bmat, ONE, &maxn, which, TWO, &maxnev, &tol, resid, &maxncv, spanVecs, &ldv,@\\
\mbox{}\verb@                iparam, ipntr, workd, workl, &lworkl, &info@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@*/@\\
\mbox{}\verb@//#else@\\
\mbox{}\verb@        dnaupd_( &ido, bmat, &maxn, which, &maxnev, &tol, resid, &maxncv, spanVecs, &ldv,@\\
\mbox{}\verb@                iparam, ipntr, workd, workl, &lworkl, &info@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /*      fflush (stdout);*/@\\
\mbox{}\verb@//#endif@\\
\mbox{}\verb@        time_arpack += (cputime() - time0) ;@\\
\mbox{}\verb@        if (info != 0) {@\\
\mbox{}\verb@                printf ("error return from dnaupd, ierr=%d\n", info) ;@\\
\mbox{}\verb@                return(0) ;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* iterate on candidate eigenvectors until convergence */@\\
\mbox{}\verb@        count_useArpack = 0 ;@\\
\mbox{}\verb@        while(ido==1||ido==(-1)){@\\
\mbox{}\verb@@\\
\mbox{}\verb@                time0 = cputime() ;@\\
\mbox{}\verb@            sparseMatTimesVec(&maxn,amat,amatj,amati, workd+ipntr[0]-1, workd+ipntr[1]-1);@\\
\mbox{}\verb@                time_sparseMatTimesVec += (cputime() - time0) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                time0 = cputime() ;@\\
\mbox{}\verb@/* Fortran calls in Win32 require hidden args for string length */@\\
\mbox{}\verb@/* strings are char arrays, so don't take addresses when calling */@\\
\mbox{}\verb@/* #ifdef WIN32@\\
\mbox{}\verb@            dnaupd_( &ido, bmat, ONE, &maxn, which, TWO, &maxnev, &tol, resid, &maxncv, spanVecs, &ldv,@\\
\mbox{}\verb@                iparam, ipntr, workd, workl, &lworkl, &info@\\
\mbox{}\verb@            );@\\
\mbox{}\verb@*/@\\
\mbox{}\verb@// #else@\\
\mbox{}\verb@            dnaupd_( &ido, bmat, &maxn, which, &maxnev, &tol, resid, &maxncv, spanVecs, &ldv,@\\
\mbox{}\verb@                iparam, ipntr, workd, workl, &lworkl, &info@\\
\mbox{}\verb@            );@\\
\mbox{}\verb@// #endif@\\
\mbox{}\verb@                time_arpack += (cputime() - time0) ;@\\
\mbox{}\verb@                if (info != 0) {@\\
\mbox{}\verb@                        printf ("error return from dnaupd, ierr=%d\n", info) ;@\\
\mbox{}\verb@                        return(0u) ;@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@@\\
\mbox{}\verb@                count_useArpack ++ ;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* call dneupd to retrive eigenvectors and values */@\\
\mbox{}\verb@        time0 = cputime() ;@\\
\mbox{}\verb@/* Fortran calls in Win32 require hidden args for string length */@\\
\mbox{}\verb@/* strings are char arrays, so don't take addresses when calling */@\\
\mbox{}\verb@/*#ifdef WIN32@\\
\mbox{}\verb@        dneupd_( &rvec, huhmat, ONE, select, rootr, rooti, spanVecs, &ldv,@\\
\mbox{}\verb@                 &sigmar, &sigmai, workev, bmat, ONE, &maxn, which, TWO, &maxnev, &tol,@\\
\mbox{}\verb@                 resid, &maxncv, spanVecs, &ldv, iparam, ipntr, workd, workl,@\\
\mbox{}\verb@                 &lworkl, &info@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@#else@\\
\mbox{}\verb@*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*              printf ("calling dneupd, tol=%e\n", tol) ;*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        dneupd_( &rvec, huhmat, select, rootr, rooti, spanVecs, &ldv,@\\
\mbox{}\verb@                 &sigmar, &sigmai, workev, bmat, &maxn, which, &maxnev, &tol,@\\
\mbox{}\verb@                 resid, &maxncv, spanVecs, &ldv, iparam, ipntr, workd, workl,@\\
\mbox{}\verb@                 &lworkl, &info@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@// #endif@\\
\mbox{}\verb@        time_arpack += (cputime() - time0) ;@\\
\mbox{}\verb@        if (info != 0) {@\\
\mbox{}\verb@                printf ("error return from dneupd, ierr=%d\n", info) ;@\\
\mbox{}\verb@                return(0u) ;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* compute number of large roots; find row num of smallest root (may have been added for B-K test) */@\\
\mbox{}\verb@        *nlarge = 0 ;@\\
\mbox{}\verb@        lowroot = 0.0 ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* loop through roots */@\\
\mbox{}\verb@        for (i=0; i<maxnev; i++) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* magnitude of this root */@\\
\mbox{}\verb@                realpart = rootr[i];@\\
\mbox{}\verb@                imagpart = rooti[i];@\\
\mbox{}\verb@        thisroot = sqrt(realpart*realpart + imagpart*imagpart);@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* count large roots */@\\
\mbox{}\verb@                if (thisroot > 1+ZERO_TOL1)@\\
\mbox{}\verb@                        *nlarge = *nlarge + 1 ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* keep track of smallest root */@\\
\mbox{}\verb@        if (i == 0 || thisroot < lowroot) {@\\
\mbox{}\verb@                        lowroot = thisroot;@\\
\mbox{}\verb@                        lowpos = i;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        } /* end for */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* if testing Blanchard-Kahn conditions, and if smallest root is not large,@\\
\mbox{}\verb@           delete row we added for test.  If smallest root is large, B-K conditions@\\
\mbox{}\verb@           fail and we want to report extra large root to user.  If smallest root is@\\
\mbox{}\verb@           not large, B-K conditions may be satisfied, and we don't want the extra@\\
\mbox{}\verb@           row in the matrix.@\\
\mbox{}\verb@        */@\\
\mbox{}\verb@#define BKFIXUP 0@\\
\mbox{}\verb@        if (BKFIXUP && TESTBLANCHARDKAHN && lowroot <= 1+ZERO_TOL1) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@                printf ("useArpack:  deleting row %d\n", lowpos+1) ;@\\
\mbox{}\verb@                deleteRow (lowpos+1, rootr, maxnev, 1) ;@\\
\mbox{}\verb@                deleteRow (lowpos+1, rooti, maxnev, 1) ;@\\
\mbox{}\verb@                deleteRow (lowpos+1, spanVecs, maxnev, nroot) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* the extra root might have been a conjugate pair, in which case dneupd would@\\
\mbox{}\verb@                have increased maxnev by one and added one more row.  Delete that one, too */@\\
\mbox{}\verb@                if (maxnev-original_maxnev >= 2) {@\\
\mbox{}\verb@                        printf ("useArpack:  deleting conjugate row %d\n", lowpos+1) ;@\\
\mbox{}\verb@                        deleteRow (lowpos+1, rootr, maxnev, 1) ;@\\
\mbox{}\verb@                        deleteRow (lowpos+1, rooti, maxnev, 1) ;@\\
\mbox{}\verb@                        deleteRow (lowpos+1, spanVecs, maxnev, nroot) ;@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        }       /* TESTBLANCHARDKAHN */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        free(iparam);@\\
\mbox{}\verb@        free(ipntr);@\\
\mbox{}\verb@        free(select);@\\
\mbox{}\verb@        free(ax);@\\
\mbox{}\verb@        free(d);@\\
\mbox{}\verb@        free(resid);@\\
\mbox{}\verb@        free(v);@\\
\mbox{}\verb@        free(workev);@\\
\mbox{}\verb@        free(workl);@\\
\mbox{}\verb@        free(workd);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        return (0) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@} /* use Arpack */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !augmentQmatWithInvariantSpaceVectors                           */@\\
\mbox{}\verb@/* rwt add profiling                                               */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* -----------------------------------------------------------------------------------@\\
\mbox{}\verb@        this documentation is based on the old faim program ...@\\
\mbox{}\verb@@\\
\mbox{}\verb@    premultiplies h by the negative inverse of htheta.  The left@\\
\mbox{}\verb@    part of h (all but htheta, the rightmost block) will be referred to@\\
\mbox{}\verb@    now as gamma.  A vector js is made to contain zeros for each zero@\\
\mbox{}\verb@    column of gamma.  Nonzero entries in js (corresponding to nonzero@\\
\mbox{}\verb@    columns in gamma) are numbered (1,2,...,nroot) -- nroot is the number of@\\
\mbox{}\verb@    nonzero columns in gamma.  gcols is the total number of columns in@\\
\mbox{}\verb@    gamma.@\\
\mbox{}\verb@@\\
\mbox{}\verb@    if there are any nonzero columns in gamma, constructs a matrix@\\
\mbox{}\verb@    A, which is a squeezed down version of a state transition matrix Q.@\\
\mbox{}\verb@    (A is the rows and columns of Q corresponding to nonzero entries in js.)@\\
\mbox{}\verb@@\\
\mbox{}\verb@    computes vectors spanning the left invariant subspace of A and stores them@\\
\mbox{}\verb@    in w.  The eigenvalues are stored in roots.@\\
\mbox{}\verb@@\\
\mbox{}\verb@    writes any of these vectors associated with roots outside@\\
\mbox{}\verb@    the unit circle into q.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        arguments@\\
\mbox{}\verb@@\\
\mbox{}\verb@                maxNumberOfHElements                                            max size for alloc matrices@\\
\mbox{}\verb@                returnCode                                                                      return code@\\
\mbox{}\verb@                discreteTime                                                            discrete (0) or continuous (1)@\\
\mbox{}\verb@                hrows, hcols                                                            rows and columns of H matrix@\\
\mbox{}\verb@                hmat, hmatj, hmati                                                      H matrix in CSR format@\\
\mbox{}\verb@                annihilator, annihilatorj, annihilatori         final q matrix from QR decomposition@\\
\mbox{}\verb@                rmat, rmatj, rmati                                                      final r matrix from QR decomposition@\\
\mbox{}\verb@                prow, pcol                                                                      permutations of rows and columns@\\
\mbox{}\verb@                auxiliaryInitialConditions                                      number of aux init conditions@\\
\mbox{}\verb@                constraintsNeeded                                                       number of constraints@\\
\mbox{}\verb@                qmat, qmatj,qmati                                                       Q matrix in CSR format@\\
\mbox{}\verb@                essential                                                                       dimension of transition matrix@\\
\mbox{}\verb@                rootr, rooti                                                            vectors of roots, real and imaginary@\\
\mbox{}\verb@@\\
\mbox{}\verb@------------------------------------------------------------------------------------ */@\\
\mbox{}\verb@@\\
\mbox{}\verb@static unsigned int augmentQmatWithInvariantSpaceVectors (@\\
\mbox{}\verb@        unsigned int *maxNumberOfHElements,@\\
\mbox{}\verb@        unsigned int *returnCode,@\\
\mbox{}\verb@        unsigned int discreteTime,@\\
\mbox{}\verb@        unsigned int hrows,unsigned int hcols,@\\
\mbox{}\verb@        double * hmat,unsigned int * hmatj,unsigned int * hmati,@\\
\mbox{}\verb@        double * annihilator,unsigned int * annihilatorj,unsigned int * annihilatori,@\\
\mbox{}\verb@        double * rmat,unsigned int * rmatj,unsigned int * rmati,@\\
\mbox{}\verb@        unsigned int * prow,unsigned int * pcol,@\\
\mbox{}\verb@        unsigned int auxiliaryInitialConditions,@\\
\mbox{}\verb@        unsigned int constraintsNeeded,@\\
\mbox{}\verb@        double * qmat,unsigned int * qmatj,unsigned int * qmati,@\\
\mbox{}\verb@        unsigned int * essential,@\\
\mbox{}\verb@        double * rootr,double * rooti@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        static unsigned int maxHElementsEncountered=0;@\\
\mbox{}\verb@        unsigned int originalMaxHElements;@\\
\mbox{}\verb@        unsigned int nzmax;@\\
\mbox{}\verb@        double rconde;double rcondv;@\\
\mbox{}\verb@        char jobvs,sort,sense;@\\
\mbox{}\verb@        unsigned int sdim,*bwork;@\\
\mbox{}\verb@        unsigned int liwork;int * anotheriwork;@\\
\mbox{}\verb@        double * damat;@\\
\mbox{}\verb@        unsigned int * js;@\\
\mbox{}\verb@        unsigned int qextent;unsigned int delQextent;unsigned int j;@\\
\mbox{}\verb@        double * beyondQmat;@\\
\mbox{}\verb@        double * a;unsigned int * ia;unsigned int * ja;@\\
\mbox{}\verb@        double * ta;unsigned int * tia;unsigned int * tja;@\\
\mbox{}\verb@        unsigned int * wcols;@\\
\mbox{}\verb@        unsigned int len;int ierr;double ztol;int job;@\\
\mbox{}\verb@        unsigned int rowsInQ;@\\
\mbox{}\verb@        unsigned int i;@\\
\mbox{}\verb@        unsigned int nroot, maxroots;@\\
\mbox{}\verb@        double * work;@\\
\mbox{}\verb@        unsigned int lwork;int info;unsigned int spacedim;unsigned int rc;@\\
\mbox{}\verb@/*      unsigned int ONE=1 ;*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        double time0, time_useArpack/*,time_dgees*/, time_constructA ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        unsigned int nxt,valid;@\\
\mbox{}\verb@        originalMaxHElements=*maxNumberOfHElements;@\\
\mbox{}\verb@        time_useArpack = 0 ;@\\
\mbox{}\verb@/*      time_dgees = 0 ;*/@\\
\mbox{}\verb@        time_constructA = 0 ;@\\
\mbox{}\verb@        *returnCode = 0 ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sparseAMAAssert(constraintsNeeded>0, augmentQmatWithInvariantSpaceVectorsPreConstraints);@\\
\mbox{}\verb@    sparseAMAAssert(auxiliaryInitialConditions>=0, augmentQmatWithInvariantSpaceVectorsPreAuxiliary);@\\
\mbox{}\verb@        if (*returnCode) return (0) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@    wcols = (unsigned int *) calloc((unsigned)hcols-hrows,sizeof(int));@\\
\mbox{}\verb@    rowsInQ=(unsigned int)auxiliaryInitialConditions;@\\
\mbox{}\verb@        qextent=qmati[auxiliaryInitialConditions]-qmati[0];@\\
\mbox{}\verb@        bumpSparseAMA((qextent));@\\
\mbox{}\verb@        js=(unsigned int *)calloc((unsigned)(hcols-hrows),sizeof(int));@\\
\mbox{}\verb@@\\
\mbox{}\verb@        originalMaxHElements=*maxNumberOfHElements;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* obtain dimension of transition matrix */@\\
\mbox{}\verb@        *essential=identifyEssential(hrows, hcols, hmat, hmatj, hmati, js) ;@\\
\mbox{}\verb@        bumpSparseAMA((*essential));@\\
\mbox{}\verb@        *maxNumberOfHElements=originalMaxHElements;@\\
\mbox{}\verb@        damat=(double *)calloc((unsigned)*essential * *essential,sizeof(double));@\\
\mbox{}\verb@        nxt=1;@\\
\mbox{}\verb@        valid=TRUE;@\\
\mbox{}\verb@        for(i=0;(valid &&i<(hcols-hrows));i++) {@\\
\mbox{}\verb@                if(js[i] !=0) {@\\
\mbox{}\verb@                  if(js[i] != nxt){valid=FALSE;}@\\
\mbox{}\verb@                nxt=nxt+1;@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@        sparseAMAAssert(valid==TRUE, augmentQmatWithInvariantSpaceVectorsPostValidJs);@\\
\mbox{}\verb@        if (*returnCode) return (0) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* construct state space transition matrix A -- output is dense matrix damat */@\\
\mbox{}\verb@        time0 = cputime() ;@\\
\mbox{}\verb@        constructA(maxNumberOfHElements,returnCode,hrows,hcols,*essential,js,@\\
\mbox{}\verb@                hmat,hmatj,hmati,@\\
\mbox{}\verb@                annihilator,annihilatorj,annihilatori,@\\
\mbox{}\verb@                rmat,rmatj,rmati,@\\
\mbox{}\verb@                prow,pcol,@\\
\mbox{}\verb@                damat@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        if (*returnCode) return (0) ;@\\
\mbox{}\verb@        time_constructA += cputime() - time0 ;@\\
\mbox{}\verb@        bumpSparseAMA(*maxNumberOfHElements);@\\
\mbox{}\verb@        sparseAMAAssert(validVector(*essential* *essential,damat), augmentQmatWithInvariantSpaceVectorsPostADim);@\\
\mbox{}\verb@        if (*returnCode) return (0) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* obtain eigenvectors and roots ... */@\\
\mbox{}\verb@        if (*essential>0) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@                bumpSparseAMA(*maxNumberOfHElements);@\\
\mbox{}\verb@                *maxNumberOfHElements=originalMaxHElements;@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* !!! nroot is the dimension of the eigenproblem (not spacedim)          */@\\
\mbox{}\verb@                /* !!! spacedim is the number of eigenvalues to calculate (not nroot) */@\\
\mbox{}\verb@@\\
\mbox{}\verb@                info=0;@\\
\mbox{}\verb@                nroot=*essential;                                                                                       /* dimension of eigenproblem */@\\
\mbox{}\verb@                spacedim=constraintsNeeded-auxiliaryInitialConditions;          /* number of eigenvalues to be calculated */@\\
\mbox{}\verb@                /* GSA:  debug, too big by far only need for schur computation test */@\\
\mbox{}\verb@                lwork =  1u+nroot*(1u+2u*nroot); @\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* /\* GSA:  fix it, need to call with itdim nev and ncv so that really going to use arpack *\/ */@\\
\mbox{}\verb@@\\
\mbox{}\verb@                beyondQmat = (double *) calloc((unsigned)nroot*nroot,sizeof(double)); @\\
\mbox{}\verb@                bwork = (unsigned int*)calloc((unsigned)nroot,sizeof(int));@\\
\mbox{}\verb@                work = (double *) calloc((unsigned)(lwork ), sizeof(double));@\\
\mbox{}\verb@                a = (double *) calloc((unsigned)*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@                ja = (unsigned int *) calloc((unsigned)*maxNumberOfHElements,sizeof(int));@\\
\mbox{}\verb@                ia = (unsigned int *) calloc((unsigned)nroot+1,sizeof(int));@\\
\mbox{}\verb@                ta = (double *) calloc((unsigned)*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@                tja = (unsigned int *) calloc((unsigned)*maxNumberOfHElements,sizeof(int));@\\
\mbox{}\verb@                tia = (unsigned int *) calloc((unsigned)nroot+1,sizeof(int));@\\
\mbox{}\verb@                liwork = nroot*nroot;@\\
\mbox{}\verb@                anotheriwork = (int *) calloc((unsigned) (liwork),sizeof(int));@\\
\mbox{}\verb@@\\
\mbox{}\verb@                rowsInQ=auxiliaryInitialConditions;@\\
\mbox{}\verb@                qextent=qmati[rowsInQ]-qmati[0];@\\
\mbox{}\verb@                bumpSparseAMA((qextent+1));@\\
\mbox{}\verb@                nzmax= *maxNumberOfHElements-qextent;@\\
\mbox{}\verb@                sdim=spacedim;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* calculate eigenvectors and eigenvalues.  if dimension of eigenproblem exceeds the number@\\
\mbox{}\verb@                of eigenvalues to be calculated (nroot>spacedim), we can use arpack, else use dgees */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* dimension must exceed number of roots by 2 to use arpack */@\\
\mbox{}\verb@                /* allow one room for one more root to check B-K conditions in useArpack */@\\
\mbox{}\verb@                /* Note:  nroot == dimension of eigenproblem, spacedim == number of large roots! */@\\
\mbox{}\verb@                /* TESTBLANCHARDKAHN and USEARPACK must be set in the calling program */@\\
\mbox{}\verb@                if (USEARPACK) {@\\
\mbox{}\verb@                        if (TESTBLANCHARDKAHN)@\\
\mbox{}\verb@                                maxroots = spacedim+2+1 ;@\\
\mbox{}\verb@                        else@\\
\mbox{}\verb@                                maxroots = spacedim+2 ;@\\
\mbox{}\verb@                        if (nroot<=maxroots) {@\\
\mbox{}\verb@                          //                            printf ("unable to use ARPACK, switching to DGEESX\n") ;@\\
\mbox{}\verb@                                USEARPACK=0u ;@\\
\mbox{}\verb@                        }@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* compute eigenvectors, eigenvalues using Arpack (sparse, computes selected eigenvectors */@\\
\mbox{}\verb@                if (USEARPACK) {@\\
\mbox{}\verb@@\\
\mbox{}\verb@                  //                    printf("using ARPACK\n");@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* convert damat to sparse for useArpack */@\\
\mbox{}\verb@                        dnsToCsr(&nroot,&nroot,maxNumberOfHElements,damat,&nroot,a,ja,ia,&ierr);@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* call useArpack to compute eigenvectors and values -- store in beyondQmat, rootr, rooti */@\\
\mbox{}\verb@                        time0 = cputime() ;@\\
\mbox{}\verb@                        rc = useArpack (@\\
\mbox{}\verb@                                maxNumberOfHElements, spacedim, nroot, a, ja, ia, beyondQmat, rootr, rooti, &sdim@\\
\mbox{}\verb@                        );@\\
\mbox{}\verb@                        sparseAMAAssert (rc==0, errorReturnFromUseArpack) ;@\\
\mbox{}\verb@                        if (*returnCode) return (0u) ;@\\
\mbox{}\verb@                        time_useArpack += cputime() - time0 ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* convert eigenvectors to CSR sparse, store in space for 'a' matrix */@\\
\mbox{}\verb@                        dnsToCsr(&nroot,&spacedim,&nzmax,beyondQmat,&nroot,a,ja,ia,&ierr);@\\
\mbox{}\verb@                        bumpSparseAMA(qextent+(*essential * spacedim));@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* zero small elements in eigenvectors in 'a' */@\\
\mbox{}\verb@                        job=1;ztol=1.0e-8;len=*maxNumberOfHElements;@\\
\mbox{}\verb@                        dropSmallElements(&nroot,&job,&ztol,&len,a,ja,ia,a,ja,ia,&ierr);@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* transpose eigenvectors (not in place).  matrix won't be square, because we are only@\\
\mbox{}\verb@                        computing a subset of eigenvectors, so use csrToCscRectangular */@\\
\mbox{}\verb@                        csrToCscRectangular(&nroot,&nroot,&job,&job,a,ja,ia,ta,tja,tia);@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* compute eigenvectors, eigenvalues using dgeesx (nonsparse, computes all eigenvectors) */@\\
\mbox{}\verb@                } else {@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* compute eigenvectors and values, output stored in beyondQmat, rootr, rooti */@\\
\mbox{}\verb@                  //                    printf("using dgees\n");@\\
\mbox{}\verb@                        time0 = cputime() ;@\\
\mbox{}\verb@                        jobvs='V';sort='S';sense='B';@\\
\mbox{}\verb@                        if (discreteTime!=0){@\\
\mbox{}\verb@/* Fortran calls from C in Win32 require extra args for string length */@\\
\mbox{}\verb@/* nb strings are single chars, so take address when calling */@\\
\mbox{}\verb@/*#ifdef WIN32@\\
\mbox{}\verb@                                dgeesx_(@\\
\mbox{}\verb@                                &jobvs,ONE,&sort,ONE,discreteSelect,&sense,ONE,&nroot,damat,&nroot,@\\
\mbox{}\verb@                                &sdim,rootr,rooti,@\\
\mbox{}\verb@                                beyondQmat,&nroot,&rconde,&rcondv,@\\
\mbox{}\verb@                                work,&lwork,anotheriwork,&liwork,bwork,@\\
\mbox{}\verb@                                &info@\\
\mbox{}\verb@                                );@\\
\mbox{}\verb@#else */@\\
\mbox{}\verb@                                dgeesx_(@\\
\mbox{}\verb@                                &jobvs,&sort,discreteSelect,&sense,&nroot,damat,&nroot,@\\
\mbox{}\verb@                                &sdim,rootr,rooti,@\\
\mbox{}\verb@                                beyondQmat,&nroot,&rconde,&rcondv,@\\
\mbox{}\verb@                                work,&lwork,anotheriwork,&liwork,bwork,@\\
\mbox{}\verb@                                &info@\\
\mbox{}\verb@                                );@\\
\mbox{}\verb@// #endif@\\
\mbox{}\verb@                        } else {@\\
\mbox{}\verb@/* Fortran calls from C in Win32 require extra args for string length */@\\
\mbox{}\verb@/* nb strings are single chars, so take address when calling */@\\
\mbox{}\verb@/*#ifdef WIN32@\\
\mbox{}\verb@                                dgeesx_(@\\
\mbox{}\verb@                                &jobvs,ONE,&sort,ONE,continuousSelect,&sense,ONE,&nroot,damat,&nroot,@\\
\mbox{}\verb@                                &sdim,rootr,rooti,@\\
\mbox{}\verb@                                beyondQmat,&nroot,&rconde,&rcondv,@\\
\mbox{}\verb@                                work,&lwork,anotheriwork,&liwork,bwork,@\\
\mbox{}\verb@                                &info);@\\
\mbox{}\verb@#else */@\\
\mbox{}\verb@                                dgeesx_(@\\
\mbox{}\verb@                                &jobvs,&sort,continuousSelect,&sense,&nroot,damat,&nroot,@\\
\mbox{}\verb@                                &sdim,rootr,rooti,@\\
\mbox{}\verb@                                beyondQmat,&nroot,&rconde,&rcondv,@\\
\mbox{}\verb@                                work,&lwork,anotheriwork,&liwork,bwork,@\\
\mbox{}\verb@                                &info);@\\
\mbox{}\verb@// #endif@\\
\mbox{}\verb@                        }@\\
\mbox{}\verb@                        //                      printf("done dgees: info = %d, sdim= %d, nroot = %d\n",info,sdim,nroot);@\\
\mbox{}\verb@                        //                      printf("done dgees: rconde = %e, rcondv= %e\n",rconde,rcondv);@\\
\mbox{}\verb@/*                      time_dgees = cputime() - time0 ;*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* convert eigenvectors to CSR format, store in space for 'a' */@\\
\mbox{}\verb@                        dnsToCsr(&nroot,&nroot,&nzmax,beyondQmat,&nroot,a,ja,ia,&ierr);@\\
\mbox{}\verb@                        bumpSparseAMA(qextent+(*essential* *essential));@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* drop small elements from eigenvectors */@\\
\mbox{}\verb@                        job=1;ztol=1.0e-8;len=*maxNumberOfHElements;@\\
\mbox{}\verb@                        dropSmallElements(&nroot,&job,&ztol,&len,a,ja,ia,a,ja,ia,&ierr);@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        /* transpose matrix of eigenvectors -- square, so use csrToCsc; store in 'ta' */@\\
\mbox{}\verb@                        csrToCsc(&nroot,&job,&job,a,ja,ia,ta,tja,tia);@\\
\mbox{}\verb@@\\
\mbox{}\verb@                } /* USEARPACK */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* append matrix of eigenvectors to bottom of Q */@\\
\mbox{}\verb@                qextent=qextent+1;@\\
\mbox{}\verb@                copyMatrix(&sdim,&job,ta,tja,tia,&qextent,qmat,qmatj,qmati+rowsInQ);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* reorder columns of block of eigenvectors we just added to Q */@\\
\mbox{}\verb@                /* (to match earlier reordering of cols of H ???) */@\\
\mbox{}\verb@                delQextent=qmati[rowsInQ+sdim]-qmati[rowsInQ];  /* number of nonzeros added to Q */@\\
\mbox{}\verb@                j=0;@\\
\mbox{}\verb@                for(i=0;i<hcols-hrows;i++) {                              /* loop through extra cols in H */@\\
\mbox{}\verb@                        if (js[i]) {                                                      /* if i+1'th col of H is nonzero */@\\
\mbox{}\verb@                                wcols[j]=i+1u;                                            /* add col number to vector wcols */@\\
\mbox{}\verb@                                j++;@\\
\mbox{}\verb@                        }@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@                for(j=0;j<delQextent;j++){                                        /* loop through values added to Q */@\\
\mbox{}\verb@                        qmatj[qextent+j-1]=wcols[qmatj[qextent+j-1]-1];  /* and reset column index */@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@                bumpSparseAMA(qextent);@\\
\mbox{}\verb@            sparseAMAAssert(qextent  <= *maxNumberOfHElements, qextentTooBig);@\\
\mbox{}\verb@                if (*returnCode) return (0u) ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                /* reset rowsInQ; drop small elements one more time */@\\
\mbox{}\verb@                rowsInQ=rowsInQ+sdim;@\\
\mbox{}\verb@                job=1;ztol=1.0e-8;len=HMATSIZE;@\\
\mbox{}\verb@                dropSmallElements(&rowsInQ,&job,&ztol,&len,qmat,qmatj,qmati,qmat,qmatj,qmati,&ierr);@\\
\mbox{}\verb@@\\
\mbox{}\verb@                free(beyondQmat);free(anotheriwork);@\\
\mbox{}\verb@                free(bwork);@\\
\mbox{}\verb@                free(work);@\\
\mbox{}\verb@                free(a);free(ia);free(ja);@\\
\mbox{}\verb@                free(ta);free(tia);free(tja);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        } /* *essential > 0 */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* that's it ... */@\\
\mbox{}\verb@        free(damat);@\\
\mbox{}\verb@        free(js);@\\
\mbox{}\verb@        free(wcols);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* check Blanchard-Kahn conditions. spacedim is desired number of large roots, sdim the actual */@\\
\mbox{}\verb@        if (TESTBLANCHARDKAHN) {@\\
\mbox{}\verb@                /* note double negative -- sparseAMAAssert will negate expression we want to be true */@\\
\mbox{}\verb@                sparseAMAAssert (!(sdim<spacedim), tooFewLargeRoots) ;@\\
\mbox{}\verb@                sparseAMAAssert (!(sdim>spacedim), tooManyLargeRoots) ;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sparseAMAAssert(validCSRMatrix(rowsInQ,qmat,qmatj,qmati), augmentQmatWithInvariantSpaceVectorsPostValidQ);@\\
\mbox{}\verb@        sparseAMAAssert(validVector(*essential,rootr), augmentQmatWithInvariantSpaceVectorsPostValidRealRoot);@\\
\mbox{}\verb@        sparseAMAAssert(validVector(*essential,rooti), augmentQmatWithInvariantSpaceVectorsPostValidImagRoot);@\\
\mbox{}\verb@        sparseAMAAssert(*essential>=0, augmentQmatWithInvariantSpaceVectorsPostADim);@\\
\mbox{}\verb@        /* if error here, just set in *returnCode -- return rowsInQ as usual */@\\
\mbox{}\verb@        /* if (*returnCode) return (0) ; */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        *maxNumberOfHElements=maxHElementsEncountered;@\\
\mbox{}\verb@        return(rowsInQ);@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* augmentQmatWithInvariantSpaceVectors */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !obtainSparseReducedForm                                        */@\\
\mbox{}\verb@/* rwt add profiling                                               */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@void obtainSparseReducedForm(@\\
\mbox{}\verb@@\\
\mbox{}\verb@  unsigned int * maxNumberOfHElements,@\\
\mbox{}\verb@  unsigned int qrows, unsigned int qcols,@\\
\mbox{}\verb@  double * qmat, unsigned int * qmatj, unsigned int * qmati,@\\
\mbox{}\verb@  double * bmat, unsigned int * bmatj,  unsigned int * bmati@\\
\mbox{}\verb@@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        unsigned int maxHElementsEncountered=0;@\\
\mbox{}\verb@        double * nsSumC;int ierr;double * x;@\\
\mbox{}\verb@        unsigned int nzmaxLeft;double aSmallDouble;@\\
\mbox{}\verb@        unsigned int cmatsExtent;unsigned int i;unsigned int cColumns;@\\
\mbox{}\verb@        double *b;unsigned int *jb,*ib;@\\
\mbox{}\verb@        double *tb;unsigned int *jtb,*itb;@\\
\mbox{}\verb@        unsigned int  trans;@\\
\mbox{}\verb@    double * qrmat; unsigned int * qrmatj; unsigned int * qrmati;@\\
\mbox{}\verb@        int *iw;double * w;@\\
\mbox{}\verb@         unsigned int  aOne;  unsigned int  firstColumn;unsigned int  lastColumn;@\\
\mbox{}\verb@        int  nr;int  nc;unsigned int nonZeroNow;unsigned int nzmax;@\\
\mbox{}\verb@        int * jcn;@\\
\mbox{}\verb@        double * cntl;@\\
\mbox{}\verb@        int * icntl;@\\
\mbox{}\verb@        int * ip ;@\\
\mbox{}\verb@        int * np;@\\
\mbox{}\verb@        int * jfirst;@\\
\mbox{}\verb@        int * lenr;@\\
\mbox{}\verb@        int * lastr;@\\
\mbox{}\verb@        int * nextr;@\\
\mbox{}\verb@        int * ifirst;@\\
\mbox{}\verb@        int * lenc;@\\
\mbox{}\verb@        int * lastc;@\\
\mbox{}\verb@        int * nextc;@\\
\mbox{}\verb@        int * info;@\\
\mbox{}\verb@        double * rinfo;@\\
\mbox{}\verb@        unsigned int *lfact;@\\
\mbox{}\verb@        double * fact;@\\
\mbox{}\verb@        int *irnf;@\\
\mbox{}\verb@        int * iptrl;@\\
\mbox{}\verb@        int * iptru;@\\
\mbox{}\verb@/*      int originalMaxHElements;*/@\\
\mbox{}\verb@/*      double time0 ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        originalMaxHElements=*maxNumberOfHElements;@\\
\mbox{}\verb@        time0 = cputime() ;*/ /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* allocate space for args to ma50bd, etc */@\\
\mbox{}\verb@        jcn = (int *)calloc(*maxNumberOfHElements,sizeof(int));@\\
\mbox{}\verb@        cntl= (double *)calloc(5,sizeof(double));@\\
\mbox{}\verb@        icntl= (int *)calloc(9,sizeof(int));@\\
\mbox{}\verb@        ip = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        np = (int *)calloc(1,sizeof(int));@\\
\mbox{}\verb@        jfirst = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        lenr = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        lastr = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        nextr = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        w = (double *)calloc(qrows,sizeof(double));@\\
\mbox{}\verb@        iw = (int *)calloc(3*qrows,sizeof(int));@\\
\mbox{}\verb@        ifirst = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        lenc = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        lastc = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        nextc = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        info = (int *)calloc(7,sizeof(int));@\\
\mbox{}\verb@        rinfo = (double *)calloc(1,sizeof(double));@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        qrmat = (double *) calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        qrmatj = (unsigned int *) calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        qrmati = (unsigned int *) calloc(qrows+1,sizeof(double));@\\
\mbox{}\verb@        tb = (double *) calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        jtb = (unsigned int *) calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        itb = ( unsigned int *) calloc(qcols+1,sizeof(double));@\\
\mbox{}\verb@        b = (double *) calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        jb = (unsigned int *) calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        ib = (unsigned int *) calloc(qrows+1,sizeof(unsigned int));@\\
\mbox{}\verb@@\\
\mbox{}\verb@        lfact =(unsigned int *)calloc(1,sizeof(int));@\\
\mbox{}\verb@        *lfact = (  *maxNumberOfHElements);/*pessimistic setting for filling*/@\\
\mbox{}\verb@        fact = (double *)calloc(*lfact,sizeof(double));@\\
\mbox{}\verb@        irnf = (int *)calloc(*lfact,sizeof(int));@\\
\mbox{}\verb@        iptrl = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        iptru = (int *)calloc(qrows,sizeof(int));@\\
\mbox{}\verb@        x = (double *)calloc(  qcols,sizeof(double));@\\
\mbox{}\verb@        nsSumC = (double *)calloc(qrows ,sizeof(double));@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /*solve relation Qr xr = Ql xl and change sign later note xl are just@\\
\mbox{}\verb@        elements of identity matrix so that  solving Qr xr = Ql will give us@\\
\mbox{}\verb@        Bmatrix but with wrong sign*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /*still using CSR consequently doing everything to the transpose */@\\
\mbox{}\verb@        /*note ma50ad modifies its A argument*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        firstColumn=(qcols-qrows+1);@\\
\mbox{}\verb@        lastColumn=qcols;@\\
\mbox{}\verb@        aOne=1;@\\
\mbox{}\verb@        extractSubmatrix (&qrows,&aOne,&aOne,&qrows,&firstColumn,&lastColumn,@\\
\mbox{}\verb@                qmat,qmatj,qmati,&nr,&nc, qrmat,qrmatj,qrmati@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@@\\
\mbox{}\verb@        nonZeroNow=qrmati[qrows]-qrmati[0];@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        ma50id_(cntl,icntl);@\\
\mbox{}\verb@        nzmax=*maxNumberOfHElements;@\\
\mbox{}\verb@@\\
\mbox{}\verb@         useMA50AD(&qrows,&qrows,&nonZeroNow,@\\
\mbox{}\verb@                &nzmax,qrmat,qrmatj,jcn,qrmati,cntl,icntl,@\\
\mbox{}\verb@                ip,np,jfirst,lenr,lastr,nextr,iw,ifirst,lenc,lastc,nextc,info,rinfo@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        bumpSparseAMA(info[3]);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* restore odd since ad is destructive*/@\\
\mbox{}\verb@        extractSubmatrix(&qrows,&aOne,&aOne,&qrows,@\\
\mbox{}\verb@                &firstColumn,&lastColumn,@\\
\mbox{}\verb@                qmat,qmatj,qmati,&nr,&nc,@\\
\mbox{}\verb@                qrmat,qrmatj,jcn@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@@\\
\mbox{}\verb@        useMA50BD(&qrows,&qrows,&nonZeroNow,&aOne,@\\
\mbox{}\verb@                qrmat,qrmatj,jcn,@\\
\mbox{}\verb@                cntl,icntl,ip,qrmati,np,lfact,fact,irnf,iptrl,iptru,@\\
\mbox{}\verb@                w,iw,info,rinfo@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        /* wordybumpSparseAMA(info[3]); */@\\
\mbox{}\verb@        bumpSparseAMA(info[3]);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /*expand sum of c's. use transpose since c column major order */@\\
\mbox{}\verb@        trans = 1;@\\
\mbox{}\verb@        itb[0]=1u;cmatsExtent=0u;@\\
\mbox{}\verb@        cColumns=(unsigned int)qcols-qrows;@\\
\mbox{}\verb@        for(i=0;i<cColumns;i++){@\\
\mbox{}\verb@@\\
\mbox{}\verb@                lastColumn = firstColumn=(1u+i);@\\
\mbox{}\verb@@\\
\mbox{}\verb@                extractSubmatrix(&qrows,&aOne,&aOne,&qrows,&firstColumn,&lastColumn,@\\
\mbox{}\verb@                        qmat,qmatj,qmati,&nr,&nc,b,jb,ib@\\
\mbox{}\verb@                );@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                csrToDns(&qrows,&aOne,b,jb,ib,nsSumC,&qrows,&ierr);@\\
\mbox{}\verb@                bumpSparseAMA(qrows);@\\
\mbox{}\verb@                if(ierr!=0){printf("*************ran out of space****************\n");return;}@\\
\mbox{}\verb@@\\
\mbox{}\verb@                useMA50CD(&qrows,&qrows,icntl,qrmati,np,&trans,@\\
\mbox{}\verb@                        lfact,fact,irnf,iptrl,iptru,@\\
\mbox{}\verb@                        nsSumC,x,w,info@\\
\mbox{}\verb@                );@\\
\mbox{}\verb@                bumpSparseAMA(qrows);@\\
\mbox{}\verb@                nzmaxLeft= nzmax-cmatsExtent-1u;@\\
\mbox{}\verb@@\\
\mbox{}\verb@                dnsToCsr(&aOne,&qrows,&nzmaxLeft,x,&aOne,tb+(itb[i]-1),jtb+(itb[i]-1),itb+i,&ierr);@\\
\mbox{}\verb@                /*wordybumpSparseAMA(info[3]);&*/@\\
\mbox{}\verb@                if(ierr!=0){printf("*************ran out of space****************\n");return;}@\\
\mbox{}\verb@                itb[i+1]=itb[i+1]+cmatsExtent;@\\
\mbox{}\verb@                itb[i]=itb[i]+cmatsExtent;@\\
\mbox{}\verb@                cmatsExtent=(unsigned int)itb[i+1]-1u;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        bumpSparseAMA(cmatsExtent);@\\
\mbox{}\verb@        aSmallDouble=ZERO_TOLERANCE;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        dropSmallElements(&cColumns,&aOne,&aSmallDouble,&nzmax,tb,jtb,itb,tb,jtb,itb,&ierr);@\\
\mbox{}\verb@        bumpSparseAMA(itb[cColumns]-itb[0]);@\\
\mbox{}\verb@        if(ierr!=0){printf("*************ran out of space****************\n");return;}@\\
\mbox{}\verb@        csrToCscRectangular(&cColumns,&qrows,&aOne,&aOne,tb,jtb,itb,bmat,bmatj,bmati);@\\
\mbox{}\verb@        /*change sign*/@\\
\mbox{}\verb@        for(i=0;i<bmati[qrows]-bmati[0];i++)bmat[i]=(-1)*bmat[i];@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb14}{14}\NWlink{nuweb15}{, 15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17}{, 17}\NWlink{nuweb18}{, 18}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap5}\raggedright\small
\NWtarget{nuweb18}{} \verb@"devsparseAMA.c"@\nobreak\ {\footnotesize {18}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        free(w);@\\
\mbox{}\verb@        free(iw);@\\
\mbox{}\verb@        free(b);@\\
\mbox{}\verb@        free(jb);@\\
\mbox{}\verb@        free(ib);@\\
\mbox{}\verb@        free(tb);@\\
\mbox{}\verb@        free(jtb);@\\
\mbox{}\verb@        free(itb);@\\
\mbox{}\verb@        free(jcn );@\\
\mbox{}\verb@        free(cntl);@\\
\mbox{}\verb@        free(icntl);@\\
\mbox{}\verb@        free(ip );@\\
\mbox{}\verb@        free(np );@\\
\mbox{}\verb@        free(jfirst );@\\
\mbox{}\verb@        free(lenr );@\\
\mbox{}\verb@        free(lastr );@\\
\mbox{}\verb@        free(nextr );@\\
\mbox{}\verb@        free(ifirst );@\\
\mbox{}\verb@        free(lenc );@\\
\mbox{}\verb@        free(lastc );@\\
\mbox{}\verb@        free(nextc );@\\
\mbox{}\verb@        free(info );@\\
\mbox{}\verb@        free(rinfo );@\\
\mbox{}\verb@        free(/* ma50bd*/qrmat );@\\
\mbox{}\verb@        free(qrmatj );@\\
\mbox{}\verb@        free(qrmati );@\\
\mbox{}\verb@        free(lfact );@\\
\mbox{}\verb@        free(fact );@\\
\mbox{}\verb@        free(irnf );@\\
\mbox{}\verb@        free(iptrl );@\\
\mbox{}\verb@        free(iptru );@\\
\mbox{}\verb@        free(x );@\\
\mbox{}\verb@        free(nsSumC );@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* rwt print profile results */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        return;@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* obtainSparseReducedForm */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !applySparseReducedForm                                        */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@void applySparseReducedForm(@\\
\mbox{}\verb@@\\
\mbox{}\verb@        unsigned int rowDim,unsigned int colDim,double * initialX,@\\
\mbox{}\verb@        double * fp,double * intercept,@\\
\mbox{}\verb@        double * bmat,unsigned int * bmatj,unsigned int * bmati,double * resultX@\\
\mbox{}\verb@@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        double * deviations;@\\
\mbox{}\verb@        unsigned int i;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        deviations = (double *) calloc(colDim,sizeof(double));@\\
\mbox{}\verb@@\\
\mbox{}\verb@        for(i=0;i<colDim;i++){@\\
\mbox{}\verb@                deviations[i]=initialX[i]-fp[(rowDim+i)%rowDim];@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sparseMatTimesVec(&rowDim,bmat,bmatj,bmati,deviations,resultX);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        for(i=0;i<rowDim;i++){@\\
\mbox{}\verb@                resultX[i]=resultX[i]+fp[(rowDim+i)%rowDim]+intercept[i];@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        free(deviations);@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* applySparseReducedForm */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !satisfiesLinearSystemQ                                         */@\\
\mbox{}\verb@/* rwt allocate space for rightMostAllZeroQ                        */@\\
\mbox{}\verb@/* rwt add profiling                                               */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@int satisfiesLinearSystemQ (@\\
\mbox{}\verb@        unsigned int *maxNumberOfHElements,@\\
\mbox{}\verb@        unsigned int hrows,unsigned int lags,   unsigned int leads,@\\
\mbox{}\verb@        double * hmat,unsigned int * hmatj,unsigned int * hmati,@\\
\mbox{}\verb@        unsigned int *  auxiliaryInitialConditions,@\\
\mbox{}\verb@        unsigned int *  rowsInQ,@\\
\mbox{}\verb@        double * bmat, unsigned int * bmatj, unsigned int * bmati,@\\
\mbox{}\verb@        unsigned int * essential,@\\
\mbox{}\verb@        double * rootr,double * rooti,double * normVec@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        int ierr;@\\
\mbox{}\verb@        unsigned int hcols;@\\
\mbox{}\verb@        unsigned int neqTimesTau;@\\
\mbox{}\verb@        unsigned int neqTimesTheta;@\\
\mbox{}\verb@        double * wkspc;@\\
\mbox{}\verb@        double * partB;unsigned int * partBj;unsigned int * partBi;@\\
\mbox{}\verb@        double * forHMult;unsigned int * forHMultj;unsigned int *forHMulti;@\\
\mbox{}\verb@        double * bTrans;unsigned int * bTransj;unsigned int *bTransi;@\\
\mbox{}\verb@        double * forBMult;unsigned int * forBMultj;unsigned int *forBMulti;@\\
\mbox{}\verb@        double * resBMult;unsigned int * resBMultj;unsigned int *resBMulti;@\\
\mbox{}\verb@        double * ltpt;unsigned int * ltptj;unsigned int * ltpti;@\\
\mbox{}\verb@        unsigned int resRows;unsigned int resCols;@\\
\mbox{}\verb@        unsigned int aOne=1;unsigned int aTwo=2;@\\
\mbox{}\verb@        unsigned int lastRow;unsigned int firstRow;unsigned int offset;@\\
\mbox{}\verb@        unsigned int ii;@\\
\mbox{}\verb@/*      int originalMaxHElements;*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        unsigned int maxHElementsEncountered=0;@\\
\mbox{}\verb@/*      originalMaxHElements=*maxNumberOfHElements;*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        wkspc=(double *)calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        forHMult=(double *)calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        forHMultj=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        forHMulti=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        bTrans=(double *)calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        bTransj=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        bTransi=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        forBMult=(double *)calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        forBMultj=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        forBMulti=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        resBMult=(double *)calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        resBMultj=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        resBMulti=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        partB=(double *)calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        partBj=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        partBi=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        ltpt=(double *)calloc(*maxNumberOfHElements,sizeof(double));@\\
\mbox{}\verb@        ltptj=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@        ltpti=(unsigned int *)calloc(*maxNumberOfHElements,sizeof(unsigned int));@\\
\mbox{}\verb@@\\
\mbox{}\verb@        neqTimesTau=hrows*lags;@\\
\mbox{}\verb@        neqTimesTheta=hrows*leads;@\\
\mbox{}\verb@        /*identity matrix at the top*/@\\
\mbox{}\verb@        for(ii=0;ii<neqTimesTau;ii++)@\\
\mbox{}\verb@                {ltpt[ii]=1;ltptj[ii]=ii+1;ltpti[ii]=ii+1;}@\\
\mbox{}\verb@        offset=ltpti[neqTimesTau]=neqTimesTau+1;@\\
\mbox{}\verb@        copyMatrix(&neqTimesTheta,&aOne,bmat,bmatj,bmati,&offset,ltpt,ltptj,ltpti+neqTimesTau);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        lastRow=neqTimesTau+neqTimesTheta;@\\
\mbox{}\verb@        firstRow=lastRow-neqTimesTau+1;@\\
\mbox{}\verb@        extractSubmatrix(&neqTimesTheta,&aOne,&firstRow,&lastRow,&aOne,&neqTimesTau,@\\
\mbox{}\verb@                ltpt,ltptj,ltpti,&resRows,&resCols,forBMult,forBMultj,forBMulti@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        firstRow=1;lastRow=hrows;@\\
\mbox{}\verb@        extractSubmatrix(&neqTimesTheta,&aOne,&firstRow,&lastRow,&aOne,&neqTimesTau,@\\
\mbox{}\verb@                bmat,bmatj,bmati,&resRows,&resCols,partB,partBj,partBi@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        @\\
\mbox{}\verb@        if(lags>0) {@\\
\mbox{}\verb@                for(ii=0;ii<(lags-1)*hrows;ii++) {@\\
\mbox{}\verb@                        bTrans[ii]=1;bTransj[ii]=hrows+ii+1;bTransi[ii]=ii+1;@\\
\mbox{}\verb@                }@\\
\mbox{}\verb@                offset=(unsigned int)(bTrans[(lags-1)*hrows]=(lags-1)*hrows+1);@\\
\mbox{}\verb@                copyMatrix(&hrows,&aOne,bmat,bmatj,bmati,&offset,bTrans,bTransj,bTransi+(lags-1)*hrows);@\\
\mbox{}\verb@        } else {@\\
\mbox{}\verb@                offset=1;@\\
\mbox{}\verb@                copyMatrix(&hrows,&aOne,bmat,bmatj,bmati,&offset,bTrans,bTransj,bTransi+neqTimesTau);@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@        bumpSparseAMA(bTransi[neqTimesTau]-bTransi[0]);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sparseMult(&neqTimesTau,&neqTimesTau,maxNumberOfHElements,wkspc,&aOne,@\\
\mbox{}\verb@                partB,partBj,partBi,@\\
\mbox{}\verb@                forBMult,forBMultj,forBMulti,@\\
\mbox{}\verb@                /*bTrans,bTransj,bTransi,*/@\\
\mbox{}\verb@                resBMult,resBMultj,resBMulti,@\\
\mbox{}\verb@                &ierr@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        if(ierr!=0){printf("*************ran out of space****************\n");return(1);}@\\
\mbox{}\verb@        bumpSparseAMA(resBMulti[neqTimesTau]-resBMulti[0]);@\\
\mbox{}\verb@        firstRow=1;lastRow=hrows;@\\
\mbox{}\verb@        extractSubmatrix(&neqTimesTheta,&aOne,&firstRow,&lastRow,&aOne,&neqTimesTau,@\\
\mbox{}\verb@                resBMult,resBMultj,resBMulti,&resRows,&resCols,partB,partBj,partBi@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        offset=ltpti[neqTimesTau+neqTimesTheta];@\\
\mbox{}\verb@@\\
\mbox{}\verb@        bumpSparseAMA (partBi[hrows]-partBi[0]+ltpti[hrows]-ltpti[0]+offset) ;@\\
\mbox{}\verb@        if (*maxNumberOfHElements<=partBi[hrows]-partBi[0]+ltpti[hrows]-ltpti[0]+offset)@\\
\mbox{}\verb@                {printf("*************ran out of space****************\n");return(1);}@\\
\mbox{}\verb@        copyMatrix(&hrows,&aOne,partB,partBj,partBi,&offset,ltpt,ltptj,ltpti+neqTimesTau+neqTimesTheta);@\\
\mbox{}\verb@        /*copyMatrix(&hrows,&aOne,resBMult,resBMultj,resBMulti,&offset,ltpt,ltptj,ltpti+neqTimesTau+neqTimesTheta);*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@        hcols=hrows*(lags+leads+1);@\\
\mbox{}\verb@        sparseMult(&hrows,&hcols,maxNumberOfHElements,wkspc,&aOne,@\\
\mbox{}\verb@                hmat,hmatj,hmati,@\\
\mbox{}\verb@                ltpt,ltptj,ltpti,@\\
\mbox{}\verb@                forHMult,forHMultj,forHMulti,@\\
\mbox{}\verb@                &ierr@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@cPrintSparse(hrows,forHMult,forHMultj,forHMulti);@\\
\mbox{}\verb@        bumpSparseAMA(ltpti[neqTimesTau+neqTimesTheta+1]-ltpti[0]);@\\
\mbox{}\verb@        bumpSparseAMA(forHMulti[hrows]-forHMulti[0]);@\\
\mbox{}\verb@        if(ierr!=0){printf("*************ran out of space****************\n");return(1);}@\\
\mbox{}\verb@        normsByRow(&hrows,&aTwo,forHMult,forHMultj,forHMulti,normVec);@\\
\mbox{}\verb@        @\\
\mbox{}\verb@cPrintMatrixNonZero(hrows,1,normVec,1.0e-8);@\\
\mbox{}\verb@        free(wkspc);@\\
\mbox{}\verb@        free(forHMult);@\\
\mbox{}\verb@        free(forHMultj);@\\
\mbox{}\verb@        free(forHMulti);@\\
\mbox{}\verb@        free(bTrans);@\\
\mbox{}\verb@        free(bTransj);@\\
\mbox{}\verb@        free(bTransi);@\\
\mbox{}\verb@        free(forBMult);@\\
\mbox{}\verb@        free(forBMultj);@\\
\mbox{}\verb@        free(forBMulti);@\\
\mbox{}\verb@        free(resBMult);@\\
\mbox{}\verb@        free(resBMultj);@\\
\mbox{}\verb@        free(resBMulti);@\\
\mbox{}\verb@        free(partB);@\\
\mbox{}\verb@        free(partBj);@\\
\mbox{}\verb@        free(partBi);@\\
\mbox{}\verb@        free(ltpt);@\\
\mbox{}\verb@        free(ltptj);@\\
\mbox{}\verb@        free(ltpti);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        *maxNumberOfHElements=maxHElementsEncountered;@\\
\mbox{}\verb@        return(0);@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* satsifiesLinearSystemQ */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@//#include "mex.h"@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@/* !sparseAMA                                                      */@\\
\mbox{}\verb@/* rwt add profiling                                               */@\\
\mbox{}\verb@/* --------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* ---------------------------------------------------------------------------------@\\
\mbox{}\verb@@\\
\mbox{}\verb@        Given the structural coefficients matrix, this routine computes@\\
\mbox{}\verb@        the statespace transition matrix, and its eigenvalues and constructs the asymptotic@\\
\mbox{}\verb@        constraints matrix.  Returns an int, the number of rows in the asymptotic constraint@\\
\mbox{}\verb@        matrix.@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@Arguments@\\
\mbox{}\verb@---------@\\
\mbox{}\verb@@\\
\mbox{}\verb@        All args should be allocated and initialized by the caller as shown below.@\\
\mbox{}\verb@        In these comments,@\\
\mbox{}\verb@                        qmax == maxNumberOfHElements@\\
\mbox{}\verb@        Arrays are assumed to be initialized to zero unless otherwise specified.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        maxNumberOfHElements (input,output)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                A pointer to a strictly positive int:  the number of elements to allocate@\\
\mbox{}\verb@                for sparse matrix storage. On output, the minimum value required to carry@\\
\mbox{}\verb@                out the computations for this function invocation.@\\
\mbox{}\verb@@\\
\mbox{}\verb@                Recommended initial guess is hrows*hcols.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        discreteTime (input)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                when non-zero, computes discrete time solutions@\\
\mbox{}\verb@                when 0 computes continuous time solutions.@\\
\mbox{}\verb@                The former case requires ruling out eigenvalues bigger than one in magnitude.@\\
\mbox{}\verb@                The latter case requires ruling out eigenvalues with positive real part.@\\
\mbox{}\verb@                The sparseAMA.h include file provides definitions for these int constants.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        hrows (input)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                a strictly positive int characterizing the number of rows in hmat@\\
\mbox{}\verb@                also equal to the number of equations in the model, referred to here as neq@\\
\mbox{}\verb@@\\
\mbox{}\verb@        hcols (input)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                a strictly positive int characterizing the number of columns in hmat@\\
\mbox{}\verb@@\\
\mbox{}\verb@        leads (input)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                a strictly positive int characterizing the number of leads@\\
\mbox{}\verb@@\\
\mbox{}\verb@        hmat, hmatj, hmati (input)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                structural coefficients matrix in `compressed sparse row' (CSR) format.@\\
\mbox{}\verb@                The CSR data structure consists of three arrays:@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        A real array A containing the real values a_{i,j} stored row by row,@\\
\mbox{}\verb@                        from row 1 to N. The length of A is NNZ.@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        An integer array JA containing the column indices of the elements a_{i,j}@\\
\mbox{}\verb@                        as stored in the array $A$.  The length of JA is NNZ.@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        An integer array IA containing the pointers to the beginning of each row@\\
\mbox{}\verb@                        in the arrays A and JA. The content of IA(i) is the position in arrays A and JA@\\
\mbox{}\verb@                        where the i-th row starts.  The length of IA is N+1 with IA(N+1) containing the@\\
\mbox{}\verb@                        number IA(1)+NNZ, i.e., the address in A and JA of the beginning of a fictitious@\\
\mbox{}\verb@                        row N+1.@\\
\mbox{}\verb@@\\
\mbox{}\verb@                allocate as:@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        double *hmat[qmax]@\\
\mbox{}\verb@                        int *hmatj[qmax]@\\
\mbox{}\verb@                        int *hmati[hrows+1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@        newHmat, newHmatj, newHmati (output)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                transformed structural coefficients matrix in CSR format. Leading block non-singular.@\\
\mbox{}\verb@                allocate as:@\\
\mbox{}\verb@@\\
\mbox{}\verb@                        double *newHmat[qmax]@\\
\mbox{}\verb@                        int *newHmatj[qmax]@\\
\mbox{}\verb@                        int *newHmati[hrows+1]@\\
\mbox{}\verb@@\\
\mbox{}\verb@        auxiliaryInitialConditions (input,output)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                a non-negative int indicating the number of auxiliary initial conditions@\\
\mbox{}\verb@                set to zero on input unless user is pre-initializing Q with aux conditions.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        rowsInQ (input,output)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                a non-negative int indicating the number of rows in qmat.@\\
\mbox{}\verb@                set to zero on input (unless aux conditions set on input?)@\\
\mbox{}\verb@@\\
\mbox{}\verb@        qmat, qmatj, qmati (input,output)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                asymptotic constraint matrix in CSR format.@\\
\mbox{}\verb@                allocate as:@\\
\mbox{}\verb@                        double *qmat[qmax]@\\
\mbox{}\verb@                        int *qmatj[qmax]@\\
\mbox{}\verb@                        int *qmati[hrows*(nleads+nlags+1)+1]@\\
\mbox{}\verb@                where nleads == max number of leads, nlags = max number of lags@\\
\mbox{}\verb@@\\
\mbox{}\verb@        essential (output)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                a non-negative int indicating the number of elements in rootr and rooti.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        rootr (output)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                real part of transition matrix eigenvalues@\\
\mbox{}\verb@                allocate as:@\\
\mbox{}\verb@                        double *rootr[qcols]@\\
\mbox{}\verb@                where qcols == neq*(nlags+nleads)@\\
\mbox{}\verb@@\\
\mbox{}\verb@        rooti (output)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                imaginary part of transition matrix eigenvalues@\\
\mbox{}\verb@                allocate as:@\\
\mbox{}\verb@                        double *rooti[qcols]@\\
\mbox{}\verb@                where qcols == neq*(nlags+nleads)@\\
\mbox{}\verb@@\\
\mbox{}\verb@        returnCode (output)@\\
\mbox{}\verb@@\\
\mbox{}\verb@                ASYMPTOTIC_LINEAR_CONSTRAINTS_AVAILABLE 0@\\
\mbox{}\verb@                STACKED_SYSTEM_NOT_FULL_RANK 2000@\\
\mbox{}\verb@                sparseAMA_PRECONDITIONS_VIOLATED 2001@\\
\mbox{}\verb@                autoRegression_POSTCONDITIONS_VIOLATED 2002@\\
\mbox{}\verb@                augmentQmatWithInvariantSpaceVectors_PRECONDITIONS_VIOLATED 2003@\\
\mbox{}\verb@                augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED 2004@\\
\mbox{}\verb@                shiftRightAndRecord_PRECONDITIONS_VIOLATED 2005@\\
\mbox{}\verb@                annihilateRows_POSTCONDITIONS_VIOLATED 2006@\\
\mbox{}\verb@                HELEMS_TOO_SMALL 2007@\\
\mbox{}\verb@                AMAT_TOO_LARGE 2008@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@                not used in the default implementation.@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        'global' variables@\\
\mbox{}\verb@@\\
\mbox{}\verb@                double ZERO_TOLERANCE@\\
\mbox{}\verb@                double ZERO_TOL1@\\
\mbox{}\verb@                int USEARPACK@\\
\mbox{}\verb@                int TESTBLANCHARDKAHN@\\
\mbox{}\verb@@\\
\mbox{}\verb@        must all be declared and set in the calling program.@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@---------------------------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@void sparseAMA (@\\
\mbox{}\verb@unsigned int *maxNumberOfHElements,             @\\
\mbox{}\verb@    unsigned int discreteTime,@\\
\mbox{}\verb@    unsigned int hrows,unsigned int hcols,@\\
\mbox{}\verb@    unsigned int leads,@\\
\mbox{}\verb@    double * hmat,unsigned int * hmatj,unsigned int * hmati,@\\
\mbox{}\verb@    double * newHmat,unsigned int * newHmatj,unsigned int * newHmati,@\\
\mbox{}\verb@    unsigned int *  auxiliaryInitialConditions,@\\
\mbox{}\verb@    unsigned int *  rowsInQ,@\\
\mbox{}\verb@    double * qmat,unsigned int * qmatj,unsigned int * qmati,@\\
\mbox{}\verb@    unsigned int * essential,@\\
\mbox{}\verb@    double * rootr,double * rooti,@\\
\mbox{}\verb@    unsigned int *returnCode@\\
\mbox{}\verb@)@\\
\mbox{}\verb@{@\\
\mbox{}\verb@        static unsigned int maxHElementsEncountered=0;@\\
\mbox{}\verb@        unsigned int originalMaxHElements;@\\
\mbox{}\verb@        double * annihilator;unsigned int * annihilatorj;unsigned int * annihilatori;@\\
\mbox{}\verb@        double * rmat;unsigned int * rmatj;unsigned int * rmati;@\\
\mbox{}\verb@        unsigned int * prow;unsigned int * pcol;@\\
\mbox{}\verb@        unsigned int constraintsNeeded;@\\
\mbox{}\verb@        unsigned int i;@\\
\mbox{}\verb@        double time0 ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* Check Inputs*/@\\
\mbox{}\verb@        //cPrintSparse(hrows,hmat,hmatj,hmati);@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* save maxspace parameter -- original will be overwritten by actual */@\\
\mbox{}\verb@        originalMaxHElements=*maxNumberOfHElements;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* rwt                                                     */@\\
\mbox{}\verb@        /*totcpusec = oldcpusec = 0 is initialized in main program */@\\
\mbox{}\verb@        tmpcpusec = alloc_sec = assert_sec = qr_sec = 0.0 ; /* rwt */@\\
\mbox{}\verb@        alloc_count = assert_count = qr_count = 0 ;      /* rwt */@\\
\mbox{}\verb@        time_rightMostAllZeroQ = 0 ; /* rwt */@\\
\mbox{}\verb@        count_rightMostAllZeroQ = 0 ; /* rwt */@\\
\mbox{}\verb@        time_autoregression = time_augmentQ = 0 ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        sparseAMAAssert(*maxNumberOfHElements > 0, sparseAMAPreMaxNumberOfHElementsLEZero);@\\
\mbox{}\verb@    sparseAMAAssert(hrows > 0, sparseAMAPreHrows);@\\
\mbox{}\verb@    sparseAMAAssert((hcols > 0)&&(hcols>=hrows)&&((hcols%hrows) == 0), sparseAMAPreHcolsHrows);@\\
\mbox{}\verb@    sparseAMAAssert(leads > 0, sparseAMAPreLeads);@\\
\mbox{}\verb@        sparseAMAAssert(validCSRMatrix(hrows,hmat,hmatj,hmati), sparseAMAPreHmat);@\\
\mbox{}\verb@        sparseAMAAssert(hmati[hrows]-hmati[0]<=*maxNumberOfHElements, sparseAMAPreHmatTotElems);@\\
\mbox{}\verb@    sparseAMAAssert(*auxiliaryInitialConditions >= 0, sparseAMAPreAuxRows);@\\
\mbox{}\verb@    sparseAMAAssert(*rowsInQ>=*auxiliaryInitialConditions,sparseAMAPreRowsInQ);@\\
\mbox{}\verb@        sparseAMAAssert(*rowsInQ==0||validCSRMatrix(*rowsInQ,qmat,qmatj,qmati),sparseAMAPreQmat);@\\
\mbox{}\verb@        if (*returnCode) return ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        annihilator=(double *) calloc((unsigned)RBLOCKSIZE,sizeof(double));@\\
\mbox{}\verb@        annihilatorj=(unsigned int *) calloc((unsigned)RBLOCKSIZE,sizeof(unsigned int));@\\
\mbox{}\verb@        annihilatori=(unsigned int *) calloc((unsigned)hrows+1,sizeof(unsigned int));@\\
\mbox{}\verb@        rmat=(double *)calloc((unsigned)RBLOCKSIZE,sizeof(double));@\\
\mbox{}\verb@        rmatj=(unsigned int *)calloc((unsigned)RBLOCKSIZE,sizeof(unsigned int));@\\
\mbox{}\verb@        rmati=(unsigned int *)calloc((unsigned)hrows+1,sizeof(unsigned int));@\\
\mbox{}\verb@        prow=(unsigned int *) calloc((unsigned)hrows,sizeof(unsigned int));@\\
\mbox{}\verb@        pcol=(unsigned int *) calloc((unsigned)hrows,sizeof(unsigned int));@\\
\mbox{}\verb@        /* originalMaxHElements=*maxNumberOfHElements; just did this above */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        for(i=0;i<=hrows;i++) {@\\
\mbox{}\verb@                rmati[i]=annihilatori[i]=1;@\\
\mbox{}\verb@        }@\\
\mbox{}\verb@@\\
\mbox{}\verb@        qmati[0]=1;@\\
\mbox{}\verb@        time0 = cputime() ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* ----------------------------------- */@\\
\mbox{}\verb@        /* 1. autoRegression                   */@\\
\mbox{}\verb@        /* ----------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* -----------------------------------------------------------------------------------@\\
\mbox{}\verb@        In addition to the number of auxiliary initial conditions, the call to@\\
\mbox{}\verb@        autoRegression() returns several sparse matrices:@\\
\mbox{}\verb@@\\
\mbox{}\verb@                newHmat, newHmatj, newHmati@\\
\mbox{}\verb@                        The transformed structural coefficients matrix.@\\
\mbox{}\verb@                        The algorithm constructs a matrix with a non-singular right-hand block.@\\
\mbox{}\verb@@\\
\mbox{}\verb@                annihilator, annihilatorj, annihilatori@\\
\mbox{}\verb@                        The Q matrix in the final rank determining QR-Decomposition.@\\
\mbox{}\verb@@\\
\mbox{}\verb@                rmat, rmatj, rmati@\\
\mbox{}\verb@                                The R matrix in the final rank determining QR-Decomposition.@\\
\mbox{}\verb@@\\
\mbox{}\verb@        The routine also returns the row and column permutations used in the QR-Decomposition@\\
\mbox{}\verb@        (prow and pcol).  Subsequent routines use the QR-Decomposition matrix to avoid@\\
\mbox{}\verb@        computing the inverse of the right-hand block of the transformed structural@\\
\mbox{}\verb@        coefficients matrix.@\\
\mbox{}\verb@        ------------------------------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        *returnCode=0;@\\
\mbox{}\verb@        *auxiliaryInitialConditions=autoRegression(@\\
\mbox{}\verb@                maxNumberOfHElements,returnCode,@\\
\mbox{}\verb@        hrows,hcols,@\\
\mbox{}\verb@        hmat,hmatj,hmati,@\\
\mbox{}\verb@        qmat,qmatj,qmati,@\\
\mbox{}\verb@        newHmat,newHmatj,newHmati,@\\
\mbox{}\verb@        annihilator,annihilatorj,annihilatori,@\\
\mbox{}\verb@        rmat,rmatj,rmati,@\\
\mbox{}\verb@        prow,pcol@\\
\mbox{}\verb@@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        if (*returnCode) return ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* record max space actually used and reset limit to original value */@\\
\mbox{}\verb@        bumpSparseAMA(*maxNumberOfHElements);@\\
\mbox{}\verb@        *maxNumberOfHElements=originalMaxHElements;@\\
\mbox{}\verb@        time_autoregression = cputime() - time0 ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* --------------------------------------- */@\\
\mbox{}\verb@        /* 2. augmentQmatWithInvariantSpaceVectors */@\\
\mbox{}\verb@        /* --------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* -----------------------------------------------------------------------------------@\\
\mbox{}\verb@        In addition to returning the number of rows in the asymptotic constraint matrix,@\\
\mbox{}\verb@        the call to augmentQmatWithInvariantSpaceVectors returns several matrices:@\\
\mbox{}\verb@@\\
\mbox{}\verb@                qmat, qmatj, qmati      matrix of asymptotic constraints in CSR format@\\
\mbox{}\verb@                amat                            transition matrix in dense format@\\
\mbox{}\verb@                rootr                           real part of the eignvalues@\\
\mbox{}\verb@                rooti                           imaginary part of the eignvalues@\\
\mbox{}\verb@                js                                      a vector indicating which columns of the original structural@\\
\mbox{}\verb@                                                        coefficients matrix correspond to the columns of the transition matrix.@\\
\mbox{}\verb@                essential                       dimension of the transition matrix@\\
\mbox{}\verb@   -------------------------------------------------------------------------------------- */@\\
\mbox{}\verb@@\\
\mbox{}\verb@        constraintsNeeded=leads*hrows;@\\
\mbox{}\verb@        time0 = cputime() ; /* rwt */@\\
\mbox{}\verb@        *rowsInQ=augmentQmatWithInvariantSpaceVectors(@\\
\mbox{}\verb@@\\
\mbox{}\verb@                maxNumberOfHElements,returnCode,discreteTime,@\\
\mbox{}\verb@        hrows,hcols,@\\
\mbox{}\verb@        hmat,hmatj,hmati,@\\
\mbox{}\verb@        annihilator,annihilatorj,annihilatori,@\\
\mbox{}\verb@        rmat,rmatj,rmati,@\\
\mbox{}\verb@        prow,pcol,@\\
\mbox{}\verb@        *auxiliaryInitialConditions,@\\
\mbox{}\verb@        constraintsNeeded,@\\
\mbox{}\verb@        qmat,qmatj,qmati,@\\
\mbox{}\verb@        essential,@\\
\mbox{}\verb@        rootr,rooti@\\
\mbox{}\verb@@\\
\mbox{}\verb@        );@\\
\mbox{}\verb@        if (*returnCode) return ;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* record max space actually used and reset limit to original value */@\\
\mbox{}\verb@        bumpSparseAMA(*maxNumberOfHElements);@\\
\mbox{}\verb@        *maxNumberOfHElements=originalMaxHElements;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        time_augmentQ = cputime() - time0 ; /* rwt */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@        /* save max space used where user can find it */@\\
\mbox{}\verb@        *maxNumberOfHElements = maxHElementsEncountered;@\\
\mbox{}\verb@@\\
\mbox{}\verb@        free(annihilator);@\\
\mbox{}\verb@        free(annihilatorj);@\\
\mbox{}\verb@        free(annihilatori);@\\
\mbox{}\verb@        free(rmat);@\\
\mbox{}\verb@        free(rmatj);@\\
\mbox{}\verb@        free(rmati);@\\
\mbox{}\verb@        free(prow);@\\
\mbox{}\verb@        free(pcol);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@}       /* sparseAMA */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* ******************************************************************************************* */@\\
\mbox{}\verb@/* ******************************************************************************************* */@\\
\mbox{}\verb@/*                               end sparseAMA.c                                               */@\\
\mbox{}\verb@/* ******************************************************************************************* */@\\
\mbox{}\verb@/* ******************************************************************************************* */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \NWtxtFileDefBy\ \NWlink{nuweb14}{14}\NWlink{nuweb15}{, 15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17}{, 17}\NWlink{nuweb18}{, 18}.

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\begin{flushleft} \small
\begin{minipage}{\linewidth}\label{scrap6}\raggedright\small
\NWtarget{nuweb19}{} \verb@"devuseSparseAMA.h"@\nobreak\ {\footnotesize {19}}$\equiv$
\vspace{-1ex}
\begin{list}{}{} \item
\mbox{}\verb@@\\
\mbox{}\verb@/*@\\
\mbox{}\verb@ * sparseAMA.h@\\
\mbox{}\verb@ */@\\
\mbox{}\verb@/* ------------------------------------------------------------------------------------------------ */@\\
\mbox{}\verb@/* rwt version of sparseAMA.h.  Numerous changes, including insert code from top of old sparseAMA.c */@\\
\mbox{}\verb@/* ------------------------------------------------------------------------------------------------ */@\\
\mbox{}\verb@@\\
\mbox{}\verb@#include <stdio.h>@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*#include <stdio.h>*/@\\
\mbox{}\verb@#include <stdlib.h>@\\
\mbox{}\verb@#include <float.h>@\\
\mbox{}\verb@#include <math.h>@\\
\mbox{}\verb@// #include "mex.h"@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define WIN32 1@\\
\mbox{}\verb@#define USESETJMP 1@\\
\mbox{}\verb@#ifdef USESETJMP@\\
\mbox{}\verb@#define _POSIX_SOURCE 1@\\
\mbox{}\verb@#endif@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define HMATSIZE (*maxNumberOfHElements)@\\
\mbox{}\verb@#define RBLOCKSIZE ( (hrows * hrows) +1)@\\
\mbox{}\verb@#define RIGHT 0@\\
\mbox{}\verb@#define NONZERO 1@\\
\mbox{}\verb@#define TRUE 1@\\
\mbox{}\verb@#define FALSE 0@\\
\mbox{}\verb@#define EXCEPT_ASSERTION_VIOLATION 9@\\
\mbox{}\verb@#define DISCRETE_TIME 1@\\
\mbox{}\verb@#define CONTINUOUS_TIME 0@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* assertion handler.  if expression is false, print linenumber, violation text, and violation number,@\\
\mbox{}\verb@then signal process, which calls fn termination_handler() */@\\
\mbox{}\verb@#ifdef DISABLEASSERTS@\\
\mbox{}\verb@#define sparseAMAAssert(expression) /*do nothing*/@\\
\mbox{}\verb@#else@\\
\mbox{}\verb@/*#define sparseAMAAssert(expression)  \@\\
\mbox{}\verb@        if(!(expression))\@\\
\mbox{}\verb@        __sparseAMAAssert (expression, __FILE__, __LINE__);@\\
\mbox{}\verb@#define __sparseAMAAssert(expression, file, lineno)  \@\\
\mbox{}\verb@        {printf("sparseAMAAssert: processid=%ld\n",getpid());\@\\
\mbox{}\verb@        printf ("%s:%u: failed assertion\n", file, lineno);\@\\
\mbox{}\verb@        printf("%s\n",lineNumberToString(lineno));\@\\
\mbox{}\verb@        printf("violation number=%d\n",(*returnCode=lineNumberToViolation(lineno)));\@\\
\mbox{}\verb@    ignoreReturnedValue=kill(getpid(),SIGUSR2);}@\\
\mbox{}\verb@*/@\\
\mbox{}\verb@#define sparseAMAAssert(expression,errcode) if(!(expression)){ \@\\
\mbox{}\verb@                printf ("%s:%u: failed assertion\n",__FILE__, __LINE__);\@\\
\mbox{}\verb@                printf("%s\n",lineNumberToString(errcode));\@\\
\mbox{}\verb@                printf("violation number=%d\n",(*returnCode=lineNumberToViolation(errcode)));}@\\
\mbox{}\verb@#endif@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* line number aliases, used by lineNumberToViolation() and lineNumberToString() */@\\
\mbox{}\verb@#define tooFewLargeRoots 1001@\\
\mbox{}\verb@#define tooManyLargeRoots 1002@\\
\mbox{}\verb@#define qextentTooBig 1430@\\
\mbox{}\verb@#define nzmaxTooSmallAnnihilateRows 1540@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectorsPostValidA 1668@\\
\mbox{}\verb@#define nzmaxTooSmallAugmentQ 1720@\\
\mbox{}\verb@#define nzmaxTooSmallConstructA 2117@\\
\mbox{}\verb@#define ndnsTooSmall 2180@\\
\mbox{}\verb@#define sparseAMAPreMaxNumberOfHElementsLEZero 2781@\\
\mbox{}\verb@#define sparseAMAPreHrows 2792@\\
\mbox{}\verb@#define sparseAMAPreHcolsHrows 2800@\\
\mbox{}\verb@#define sparseAMAPreLeads 2809@\\
\mbox{}\verb@#define sparseAMAPreHmat 2818@\\
\mbox{}\verb@#define sparseAMAPreHmatTotElems 2826@\\
\mbox{}\verb@#define sparseAMAPreAuxRows 2838@\\
\mbox{}\verb@#define sparseAMAPreRowsInQ 2848@\\
\mbox{}\verb@#define sparseAMAPreQmat 2857@\\
\mbox{}\verb@#define autoRegressionPostValidQ 3084@\\
\mbox{}\verb@#define autoRegressionPostValidH 3092@\\
\mbox{}\verb@#define autoRegressionPostValidAnnihilator 3100@\\
\mbox{}\verb@#define autoRegressionPostValidR 3108@\\
\mbox{}\verb@#define autoRegressionPostValidJs 3143@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectorsPreConstraints 3155@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectorsPreAuxiliary 3164@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectorsPostValidQ 3172@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectorsPostValidRealRoot 3180@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectorsPostValidImagRoot 3188@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectorsPostADim 3208@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectorsPostValidJs 3224@\\
\mbox{}\verb@#define shiftRightAndRecordPreZeroRow 3246@\\
\mbox{}\verb@#define annihilateRowsPostValidH 3265@\\
\mbox{}\verb@#define errorReturnFromUseArpack 4001@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* violation codes used by lineNumberToViolation */@\\
\mbox{}\verb@#define ASYMPTOTIC_LINEAR_CONSTRAINTS_AVAILABLE 0@\\
\mbox{}\verb@#define STACKED_SYSTEM_NOT_FULL_RANK 2000@\\
\mbox{}\verb@#define sparseAMA_PRECONDITIONS_VIOLATED 2001@\\
\mbox{}\verb@#define autoRegression_POSTCONDITIONS_VIOLATED 2002@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectors_PRECONDITIONS_VIOLATED 2003@\\
\mbox{}\verb@#define augmentQmatWithInvariantSpaceVectors_POSTCONDITIONS_VIOLATED 2004@\\
\mbox{}\verb@#define shiftRightAndRecord_PRECONDITIONS_VIOLATED 2005@\\
\mbox{}\verb@#define annihilateRows_POSTCONDITIONS_VIOLATED 2006@\\
\mbox{}\verb@#define HELEMS_TOO_SMALL 2007@\\
\mbox{}\verb@#define AMAT_TOO_LARGE 2008@\\
\mbox{}\verb@#define TOO_FEW_LARGE_ROOTS 2009@\\
\mbox{}\verb@#define TOO_MANY_LARGE_ROOTS 2010@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* declare library fns used by sparseAMA */@\\
\mbox{}\verb@unsigned int validCSRMatrix( unsigned int numRows,double * mata,unsigned int * matj,unsigned int *mati);@\\
\mbox{}\verb@int validVector(unsigned int numRows,double * vec);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*void exit(int status);@\\
\mbox{}\verb@long getpid();@\\
\mbox{}\verb@void * calloc(unsigned amt,unsigned size);@\\
\mbox{}\verb@*/@\\
\mbox{}\verb@/*@\\
\mbox{}\verb@void submat_();@\\
\mbox{}\verb@void free();@\\
\mbox{}\verb@void copmat_();@\\
\mbox{}\verb@void rperm_();@\\
\mbox{}\verb@void filter_();@\\
\mbox{}\verb@void cnrms_();@\\
\mbox{}\verb@void getdia_();@\\
\mbox{}\verb@void csrdns_();@\\
\mbox{}\verb@void csrcsc_();@\\
\mbox{}\verb@void dnscsr_();@\\
\mbox{}\verb@void usol_();@\\
\mbox{}\verb@int coocsr_() ;@\\
\mbox{}\verb@extern void csrcsc2_();@\\
\mbox{}\verb@extern void amux_();@\\
\mbox{}\verb@void getu_();@\\
\mbox{}\verb@void transp_();@\\
\mbox{}\verb@void rnrms_();@\\
\mbox{}\verb@*/@\\
\mbox{}\verb@int satisfiesLinearSystemQ (@\\
\mbox{}\verb@        unsigned int *maxNumberOfHElements,@\\
\mbox{}\verb@        unsigned int hrows,unsigned int lags,   unsigned int leads,@\\
\mbox{}\verb@        double * hmat,unsigned int * hmatj,unsigned int * hmati,@\\
\mbox{}\verb@        unsigned int *  auxiliaryInitialConditions,@\\
\mbox{}\verb@        unsigned int *  rowsInQ,@\\
\mbox{}\verb@        double * bmat, unsigned int * bmatj, unsigned int * bmati,@\\
\mbox{}\verb@        unsigned int * essential,@\\
\mbox{}\verb@        double * rootr,double * rooti,double * normVec@\\
\mbox{}\verb@);@\\
\mbox{}\verb@void obtainSparseReducedForm(@\\
\mbox{}\verb@@\\
\mbox{}\verb@  unsigned int * maxNumberOfHElements,@\\
\mbox{}\verb@  unsigned int qrows, unsigned int qcols,@\\
\mbox{}\verb@  double * qmat, unsigned int * qmatj, unsigned int * qmati,@\\
\mbox{}\verb@  double * bmat, unsigned int * bmatj,  unsigned int * bmati@\\
\mbox{}\verb@@\\
\mbox{}\verb@);@\\
\mbox{}\verb@/*@\\
\mbox{}\verb@int lineNumberToViolation(int lineNo);@\\
\mbox{}\verb@char * lineNumberToString(int lineNo);@\\
\mbox{}\verb@int deleteRow (int targetRow, double *mat, int nrows, int ncols) ;@\\
\mbox{}\verb@*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/* bumpSparseAMA keeps track of max space used by program, stored in maxHElementsEncountered.@\\
\mbox{}\verb@any fn using this macro must declare static int maxHElementsEncountered=0; */@\\
\mbox{}\verb@#ifdef DEBUG@\\
\mbox{}\verb@#define bumpSparseAMA(potentialMaxValue) \@\\
\mbox{}\verb@        if(potentialMaxValue>maxHElementsEncountered) \@\\
\mbox{}\verb@        maxHElementsEncountered=(unsigned int))(potentialMaxValue);     \       printf("bumpSparseAMA stuff(%d,%d) at line %d\n", \@\\
\mbox{}\verb@        potentialMaxValue,maxHElementsEncountered,__LINE__);@\\
\mbox{}\verb@#else@\\
\mbox{}\verb@#define bumpSparseAMA(potentialMaxValue) \@\\
\mbox{}\verb@   if(potentialMaxValue>maxHElementsEncountered) \@\\
\mbox{}\verb@     maxHElementsEncountered=(unsigned int)(potentialMaxValue);@\\
\mbox{}\verb@#endif@\\
\mbox{}\verb@#define wordyBumpSparseAMA(potentialMaxValue) \@\\
\mbox{}\verb@        if(potentialMaxValue>maxHElementsEncountered) \@\\
\mbox{}\verb@maxHElementsEncountered=(unsigned int)(potentialMaxValue);\@\\
\mbox{}\verb@        printf("bumpSparseAMA stuff(%d,%d) at line %d\n",\@\\
\mbox{}\verb@        potentialMaxValue,maxHElementsEncountered,__LINE__);@\\
\mbox{}\verb@@\\
\mbox{}\verb@void free(void * ptr);@\\
\mbox{}\verb@void cPrintMatrixNonZero(unsigned int nrows,unsigned int ncols,double *matrix,double zerotol);@\\
\mbox{}\verb@@\\
\mbox{}\verb@void cPrintSparse(unsigned int rows,double * a,unsigned int * aj,unsigned int * ai);@\\
\mbox{}\verb@@\\
\mbox{}\verb@void cPrintMatrix(unsigned int nrows,unsigned int ncols,double * matrix);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@void sparseAMA (@\\
\mbox{}\verb@unsigned int *maxNumberOfHElements,             @\\
\mbox{}\verb@    unsigned int discreteTime,@\\
\mbox{}\verb@    unsigned int hrows,unsigned int hcols,@\\
\mbox{}\verb@    unsigned int leads,@\\
\mbox{}\verb@    double * hmat,unsigned int * hmatj,unsigned int * hmati,@\\
\mbox{}\verb@    double * newHmat,unsigned int * newHmatj,unsigned int * newHmati,@\\
\mbox{}\verb@    unsigned int *  auxiliaryInitialConditions,@\\
\mbox{}\verb@    unsigned int *  rowsInQ,@\\
\mbox{}\verb@    double * qmat,unsigned int * qmatj,unsigned int * qmati,@\\
\mbox{}\verb@    unsigned int * essential,@\\
\mbox{}\verb@    double * rootr,double * rooti,@\\
\mbox{}\verb@    unsigned int *returnCode@\\
\mbox{}\verb@                );@\\
\mbox{}\verb@int aplb_(int * nrow, int * ncol, int * job, double * a, int * ja, int * ia, double * b, int * jb, int * ib, double *c, int * jc, int * ic, @\\
\mbox{}\verb@        int * nzmax, int * iw, int * ierr);@\\
\mbox{}\verb@int amub_(int * nrow, int * ncol, int * job, double * a, int * ja, int * ia, double * b, int * jb, int * ib, double *c, int * jc, int * ic, @\\
\mbox{}\verb@        int * nzmax, int * iw, int * ierr);@\\
\mbox{}\verb@int diamua_(int * nrow,  int * job, double * a, int * ja, int * ia, double * diag, double *b, int * jb, int * ib); @\\
\mbox{}\verb@@\\
\mbox{}\verb@int csrdns_(int* nrow,int* ncol,double* a,int * ja,int * ia,double * dns,int * ndns, int* ierr);@\\
\mbox{}\verb@@\\
\mbox{}\verb@int getu_(int *n, double *a,int *ja,int *ia,double *ao,int *jao,int* iao);@\\
\mbox{}\verb@@\\
\mbox{}\verb@int dnscsr_(int *nrow,int *ncol,int* nzmax,double * dns,int * ndns,double * a,int * ja,int * ia,int * ierr);@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@void dorgqr_(int *m,int * n,int * k,double * a,int * lda,double * tau,double * work,int * lwork,int * info );@\\
\mbox{}\verb@@\\
\mbox{}\verb@void transp_(int *numRows,int *numCols,double *aMat,int *aMatj,int *aMati,int *workSpace,int *errCode);@\\
\mbox{}\verb@@\\
\mbox{}\verb@int rnrms_(int * nrow,int * nrm,double* a,int * ja,int * ia,double * diag);@\\
\mbox{}\verb@@\\
\mbox{}\verb@void ma50cd_(int *m,int *n,int * k,int *icntl,int * np,int *trans,\@\\
\mbox{}\verb@int * lfact,double *fact,int *irnf,int *iptrl,int *iptru,\@\\
\mbox{}\verb@double *b,double *x,double *w,int *info);@\\
\mbox{}\verb@@\\
\mbox{}\verb@void ma50bd_(int *M,int *N,int *NE,int *JOB,double*AA,int *IRNA,int *IPTRA,double*CNTL,int *ICNTL,int *IP,int *IQ,int *NP,int *LFACT,double*FACT,int *IRNF,int *IPTRL,int *IPTRU,double*W,int *IW,int *INFO,double*RINFO);@\\
\mbox{}\verb@@\\
\mbox{}\verb@void ma50ad_(int *M,int *N,int *NE,int *LA,double *A,int *IRN,int *JCN,int *IQ,double *CNTL,int *ICNTL,int *IP,int *NP,int*JFIRST,int *LENR,int *LASTR,int *NEXTR,int *IW,int *IFIRST,int *LENC,int *LASTC,int *NEXTC,int *INFO,double *RINFO);@\\
\mbox{}\verb@/*@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@submat_@\\
\mbox{}\verb@int submat_(n, job, i1, i2, j1, j2, a, ja, ia, nr, nc, ao, @\\
\mbox{}\verb@        jao, iao)@\\
\mbox{}\verb@@\\
\mbox{}\verb@integer *n;@\\
\mbox{}\verb@integer *job, *i1, *i2, *j1, *j2;@\\
\mbox{}\verb@doublereal *a;@\\
\mbox{}\verb@integer *ja, *ia, *nr, *nc;@\\
\mbox{}\verb@doublereal *ao;@\\
\mbox{}\verb@integer *jao, *iao;@\\
\mbox{}\verb@@\\
\mbox{}\verb@rperm_@\\
\mbox{}\verb@int rperm_(nrow, a, ja, ia, ao, jao, iao, perm, job)@\\
\mbox{}\verb@integer *nrow;@\\
\mbox{}\verb@doublereal *a;@\\
\mbox{}\verb@integer *ja, *ia;@\\
\mbox{}\verb@doublereal *ao;@\\
\mbox{}\verb@integer *jao, *iao, *perm, *job;@\\
\mbox{}\verb@@\\
\mbox{}\verb@filter_@\\
\mbox{}\verb@int filter_(n, job, drptol, a, ja, ia, b, jb, ib, len, ierr)@\\
\mbox{}\verb@integer *n, *job;@\\
\mbox{}\verb@doublereal *drptol, *a;@\\
\mbox{}\verb@integer *ja, *ia;@\\
\mbox{}\verb@doublereal *b;@\\
\mbox{}\verb@integer *jb, *ib, *len, *ierr;@\\
\mbox{}\verb@@\\
\mbox{}\verb@copmat_@\\
\mbox{}\verb@int copmat_(nrow, a, ja, ia, ao, jao, iao, ipos, job)@\\
\mbox{}\verb@integer *nrow;@\\
\mbox{}\verb@doublereal *a;@\\
\mbox{}\verb@integer *ja, *ia;@\\
\mbox{}\verb@doublereal *ao;@\\
\mbox{}\verb@integer *jao, *iao, *ipos, *job;@\\
\mbox{}\verb@@\\
\mbox{}\verb@cnrms_@\\
\mbox{}\verb@int cnrms_(nrow, nrm, a, ja, ia, diag)@\\
\mbox{}\verb@integer *nrow, *nrm;@\\
\mbox{}\verb@doublereal *a;@\\
\mbox{}\verb@integer *ja, *ia;@\\
\mbox{}\verb@doublereal *diag;@\\
\mbox{}\verb@@\\
\mbox{}\verb@getdia_@\\
\mbox{}\verb@int getdia_(nrow, ncol, job, a, ja, ia, len, diag, idiag, @\\
\mbox{}\verb@        ioff)@\\
\mbox{}\verb@integer *nrow, *ncol, *job;@\\
\mbox{}\verb@doublereal *a;@\\
\mbox{}\verb@integer *ja, *ia, *len;@\\
\mbox{}\verb@doublereal *diag;@\\
\mbox{}\verb@integer *idiag, *ioff;@\\
\mbox{}\verb@@\\
\mbox{}\verb@usol_@\\
\mbox{}\verb@int usol_(n, x, y, au, jau, iau)@\\
\mbox{}\verb@integer *n;@\\
\mbox{}\verb@doublereal *x, *y, *au;@\\
\mbox{}\verb@integer *jau, *iau;@\\
\mbox{}\verb@@\\
\mbox{}\verb@dnaupd_@\\
\mbox{}\verb@amux_@\\
\mbox{}\verb@int amux_(n, x, y, a, ja, ia)@\\
\mbox{}\verb@integer *n;@\\
\mbox{}\verb@doublereal *x, *y, *a;@\\
\mbox{}\verb@integer *ja, *ia;@\\
\mbox{}\verb@@\\
\mbox{}\verb@dneupd_@\\
\mbox{}\verb@@\\
\mbox{}\verb@csrcsc2_@\\
\mbox{}\verb@int csrcsc2_();@\\
\mbox{}\verb@    csrcsc2_(n, n, job, ipos, &a[1], &ja[1], &ia[1], &ao[1], &jao[1], &iao[1])@\\
\mbox{}\verb@@\\
\mbox{}\verb@dgeesx_@\\
\mbox{}\verb@@\\
\mbox{}\verb@csrcsc_@\\
\mbox{}\verb@int csrcsc_(n, job, ipos, a, ja, ia, ao, jao, iao)@\\
\mbox{}\verb@integer *n, *job, *ipos;@\\
\mbox{}\verb@doublereal *a;@\\
\mbox{}\verb@integer *ja, *ia;@\\
\mbox{}\verb@doublereal *ao;@\\
\mbox{}\verb@integer *jao, *iao;@\\
\mbox{}\verb@@\\
\mbox{}\verb@ma50id_@\\
\mbox{}\verb@ma50ad_@\\
\mbox{}\verb@ma50bd_@\\
\mbox{}\verb@ma50cd_@\\
\mbox{}\verb@*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define sparseAMAQRD(m,n,k,a,lda,tau,work,lwork,info )\@\\
\mbox{}\verb@(dorgqr_((int *)m,(int *) n,(int *) k,(double *) a,(int *) lda,(double *) tau,(double *) work,(int *) lwork,(int *) info ))@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define sparseAdd(numRows,numCols,spaceAllocated, \@\\
\mbox{}\verb@workSpace,job, \@\\
\mbox{}\verb@aMat,aMatj,aMati, \@\\
\mbox{}\verb@bMat,bMatj,bMati, \@\\
\mbox{}\verb@cMat,cMatj,cMati, \@\\
\mbox{}\verb@errCode) \@\\
\mbox{}\verb@(aplb_((int *)numRows,(int *)numCols,(int *)job,(double  *)aMat,(int *)aMatj,(int *)aMati, \@\\
\mbox{}\verb@(double *)bMat,(int *)bMatj,(int *)bMati,(double *)cMat,(int *)cMatj,(int *)cMati, \@\\
\mbox{}\verb@(int *)spaceAllocated,(int *)workSpace,(int *)errCode))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define sparseMult(numRows,numCols,spaceAllocated, \@\\
\mbox{}\verb@workSpace,job, \@\\
\mbox{}\verb@aMat,aMatj,aMati, \@\\
\mbox{}\verb@bMat,bMatj,bMati, \@\\
\mbox{}\verb@cMat,cMatj,cMati, \@\\
\mbox{}\verb@errCode) \@\\
\mbox{}\verb@(amub_((int *)numRows,(int *)numCols,(int *)job,(double *)aMat,(int *)aMatj,(int *)aMati, \@\\
\mbox{}\verb@(double *)bMat,(int *)bMatj,(int *)bMati,(double *)cMat,(int *)cMatj,(int *)cMati, \@\\
\mbox{}\verb@(int *)spaceAllocated,(int *)workSpace,(int *)errCode))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define diagMatTimesSparseMat(numRows,job, \@\\
\mbox{}\verb@diagElems,aMat,aMatj,aMati, \@\\
\mbox{}\verb@bMat,bMatj,bMati) \@\\
\mbox{}\verb@(diamua_((int *)numRows,(int *)job,(double *)aMat,(int *)aMatj,(int *)aMati,(double *)diagElems, \@\\
\mbox{}\verb@(double *)bMat,(int *)bMatj,(int *)bMati))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define sparseMatTimesVec(numRows, \@\\
\mbox{}\verb@aMat,aMatj,aMati,xVec,yVec) \@\\
\mbox{}\verb@(amux_(numRows,xVec,yVec,aMat,aMatj,aMati))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define backSolveUnitUpperTriangular(numRows, \@\\
\mbox{}\verb@aMat,aMatj,aMati,xVec,yVec) \@\\
\mbox{}\verb@(usol_(numRows,xVec,yVec,aMat,aMatj,aMati))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define dropSmallElements(numRows,job,dropTolerance, \@\\
\mbox{}\verb@spaceAllocated, \@\\
\mbox{}\verb@aMat,aMatj,aMati, \@\\
\mbox{}\verb@bMat,bMatj,bMati, \@\\
\mbox{}\verb@errCode) \@\\
\mbox{}\verb@(filter_(numRows,job,dropTolerance,aMat,aMatj,aMati, \@\\
\mbox{}\verb@bMat,bMatj,bMati, \@\\
\mbox{}\verb@spaceAllocated,errCode))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define extractSubmatrix(numRows,job,firstRow,lastRow, \@\\
\mbox{}\verb@firstCol,lastCol, \@\\
\mbox{}\verb@aMat,aMatj,aMati,resultingRows,resultingCols, \@\\
\mbox{}\verb@bMat,bMatj,bMati) \@\\
\mbox{}\verb@(submat_(numRows,job,firstRow,lastRow,firstCol,lastCol, \@\\
\mbox{}\verb@aMat,aMatj,aMati, resultingRows,resultingCols,\@\\
\mbox{}\verb@bMat,bMatj,bMati))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define inPlaceTranspose(numRows,numCols, \@\\
\mbox{}\verb@aMat,aMatj,aMati,workSpace,errCode) \@\\
\mbox{}\verb@(transp_((int *)numRows,(int *)numCols,(double *)aMat,(int *)aMatj,(int *)aMati,(int *)workSpace,(int *)errCode))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define copyMatrix(numRows,job, \@\\
\mbox{}\verb@aMat,aMatj,aMati,copyToPos, \@\\
\mbox{}\verb@bMat,bMatj,bMati) \@\\
\mbox{}\verb@(copmat_(numRows,aMat,aMatj,aMati, \@\\
\mbox{}\verb@bMat,bMatj,bMati,\@\\
\mbox{}\verb@copyToPos,job))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define getDiagonalElements(nrow,ncol,job,a,ja,ia,len,diag,idiag,ioff)\@\\
\mbox{}\verb@(getdia_(nrow,ncol,job,a,ja,ia,len,diag,idiag,ioff))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define getUpperTriangular(n,a,ja,ia,ao,jao,iao)\@\\
\mbox{}\verb@(getu_((int *)n,(double *)a,(int *)ja,(int *)ia,(double *)ao,(int *)jao,(int *)iao))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define permuteRows(nrow,a,ja,ia,ao,jao,iao,perm,job) \@\\
\mbox{}\verb@(rperm_(nrow,a,ja,ia,ao,jao,iao,perm,job))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define permuteCols(nrow,a,ja,ia,ao,jao,iao,perm,job) \@\\
\mbox{}\verb@(cperm_(nrow,a,ja,ia,ao,jao,iao,perm,job))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define normsByRow(nrow, nrm, a, ja, ia, diag) \@\\
\mbox{}\verb@(rnrms_((int *)nrow,(int *) nrm,(double *) a,(int *) ja,(int *) ia,(double *) diag))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define csrToCsc(n,job,ipos,a,ja,ia,ao,jao,iao) \@\\
\mbox{}\verb@ (csrcsc_(n,job,ipos,a,ja,ia,ao,jao,iao))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define csrToCscRectangular(n,n2,job,ipos,a,ja,ia,ao,jao,iao)\@\\
\mbox{}\verb@(csrcsc2_(n,n2,job,ipos,a,ja,ia,ao,jao,iao))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define dnsToCsr(nrow,ncol,nzmax,dns,ndns,a,ja,ia,ierr)\@\\
\mbox{}\verb@(dnscsr_((int *)nrow,(int *)ncol,(int *)nzmax,(double *)dns,(int *)ndns,(double *)a,(int *)ja,(int *)ia,(int *)ierr))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define csrToDns(nrow,ncol,a,ja,ia,dns,ndns,ierr) \@\\
\mbox{}\verb@(csrdns_((int *)nrow,(int *)ncol,(double *)a,(int *)ja,(int *)ia,(double *)dns,(int *)ndns,(int *)ierr) )@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define useMA50CD(m,n,k,icntl,np,trans,lfact,fact,irnf,iptrl,iptru,b,x,w,info)\@\\
\mbox{}\verb@(ma50cd_((int *)m,(int *)n,(int *)k,(int *)icntl,(int *) np,(int *)trans,(int *) lfact,(double *)fact,(int *)irnf,(int *)iptrl,(int *)iptru,(double *)b,(double *)x,(double *)w,(int *)info))@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define useMA50BD(M,N,NE,JOB,AA,IRNA,IPTRA,CNTL,ICNTL,IP,IQ,NP,LFACT,FACT,IRNF,IPTRL,IPTRU,W,IW,INFO,RINFO)\@\\
\mbox{}\verb@(ma50bd_((int *)M,(int *)N,(int *)NE,(int *)JOB,(double*)AA,(int *)IRNA,(int *)IPTRA,(double*)CNTL,(int *)ICNTL,(int *)IP,(int *)IQ,(int *)NP,(int *)LFACT,(double*)FACT,(int *)IRNF,(int *)IPTRL,(int *)IPTRU,(double*)W,(int *)IW,(int *)INFO,(double*)RINFO))@\\
\mbox{}\verb@@\\
\mbox{}\verb@#define useMA50AD(M,N,NE,LA,A,IRN,JCN,IQ,CNTL,ICNTL,IP,NP,JFIRST,LENR,LASTR,NEXTR,IW,IFIRST,LENC,LASTC,NEXTC,INFO,RINFO)\@\\
\mbox{}\verb@ma50ad_((int *)M,(int *)N,(int *)NE,(int *)LA,(double *)A,(int *)IRN,(int *)JCN,(int *)IQ,(double *)CNTL,(int *)ICNTL,(int *)IP,(int *)NP,(int*)JFIRST,(int *)LENR,(int *)LASTR,(int *)NEXTR,(int *)IW,(int *)IFIRST,(int *)LENC,(int *)LASTC,(int *)NEXTC,(int *)INFO,(double *)RINFO)@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*LAPACK -- dgeqp3*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*LAPACK -- dorgqr*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*LAPACK -- dgeesx*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*HARWELL -- ma50id, ma50ad, ma50bd, ma50cd*/@\\
\mbox{}\verb@@\\
\mbox{}\verb@/*@\\
\mbox{}\verb@ *@\\
\mbox{}\verb@ *  Created on: Jun 4, 2013@\\
\mbox{}\verb@ *      Author: m1gsa00@\\
\mbox{}\verb@ */@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@\\
\mbox{}\verb@@{\NWsep}
\end{list}
\vspace{-1.5ex}
\footnotesize
\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}

\item{}
\end{list}
\end{minipage}\vspace{4ex}
\end{flushleft}
\appendix

\section{Index}
\label{sec:index}

\subsection{Ralph Tryon, Luca Guerrieri Modifications}
\label{sec:ralph-tryon-modif}

\begin{itemize}
\item  Jan 2003 	rwt reformat source file from nuweb to straight C
\item  add profiling statements throughout
\item replace DBL\_EPSILON with ZERO\_TOLERANCE, defined below.
\item   add fPrintMatrix, fPrintSparse      
\item  Mar 2003 	rwt add comments, delete unused routines, etc 
\item  3/17/03		rwt replace rightMostAllZeroQ with rowEndsInZeroBlock               (called from shiftRightAndRecord) 
\item  3/19/03     rwt drop signal/longjmp in sparseAMAAssert, use simple return  
\item  use error codes instead of line numbers in message calls   
\item  3/21/03		rwt rework test to call arpack vs dgees    
\item  3/26/03     rwt add ZERO\_TOL1 for counting large roots      
\item  4/1/03	 rwt add Blanchard-Kahn test, windows compile options  
\item  Dec 2004	lg	del fPrintMatrix and fPrintSparse so as to hook up to Matlab
\item  6/30/2010	ar 	change various "ifdef win32" statements to account for gfortran compiler 
\end{itemize}

\subsection{Files}
\label{sec:files}




{\small\begin{list}{}{\setlength{\itemsep}{-\parsep}\setlength{\itemindent}{-\leftmargin}}
\item \verb@"devsparseAMA.c"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb14}{14}\NWlink{nuweb15}{, 15}\NWlink{nuweb16}{, 16}\NWlink{nuweb17}{, 17}\NWlink{nuweb18}{, 18}.
}
\item \verb@"devuseSparseAMA.h"@ {\footnotesize {\NWtxtDefBy} \NWlink{nuweb19}{19}.}
\end{list}}


\subsection{Macros}
\label{sec:macros}


None.




\subsection{Names}
\label{sec:names}










\bibliographystyle{plainnat}
\bibliography{files,anderson}

\end{document}
